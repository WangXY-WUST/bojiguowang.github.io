<!DOCTYPE html><html lang="zh-CH"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="java学习基础"><meta name="keywords" content="后端,java"><meta name="author" content="Yang Wa"><meta name="copyright" content="Yang Wa"><title>java学习基础 | Yang Wa</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  hexoVersion: '5.4.2'
} </script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Yang Wa" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83"><span class="toc-number">1.</span> <span class="toc-text">环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">3.</span> <span class="toc-text">基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">5.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8"><span class="toc-number">7.</span> <span class="toc-text">快捷键使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88ArrayList"><span class="toc-number">9.</span> <span class="toc-text">集合ArrayList</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6"><span class="toc-number">10.</span> <span class="toc-text">进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81"><span class="toc-number">10.1.</span> <span class="toc-text">静态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">10.2.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">10.3.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">10.4.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">10.5.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">10.6.</span> <span class="toc-text">权限修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">10.7.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.8.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">10.9.</span> <span class="toc-text">内部类</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/blog/avatar.jpeg"></div><div class="author-info__name text-center">Yang Wa</div><div class="author-info__description text-center">Who killed me, and I killed who</div><div class="follow-button"><a href="">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">19</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">34</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">24</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/731-2.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Yang Wa</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" target="_blank" rel="noopener" href="https://github.com/bojiguowang/">Github</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">java学习基础</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2022-11-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF/java/">java</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2022/11/03/java/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2022/11/03/java/"></span></a><div class="post-meta-wordcount"><span>Word count: </span><span class="word-count">7.2k</span><span class="post-meta__separator">|</span><span>Reading time: 26 min</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ol>
<li>java跨平台的原因是因为java是运行在虚拟机上的，针对不同的设备安装不同的虚拟机即可</li>
<li>JVM：java虚拟机，真正运行java程序的地方</li>
<li>核心类库：java封装好的一些类</li>
<li>开发工具：包括javac（编译工具），java（运行工具），jdb（调试工具），jhat（内存分析工具）等等</li>
<li>JDK：java开发工具包，由JVM+核心类库+开发工具组成</li>
<li>JRE：java运行环境。由JVM+核心类库+运行工具。当别人把编译后的文件发送给其他人进行运行时，只需要安装JRE即可。</li>
</ol>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol>
<li>字面量类型：整数，小数，字符串（双引号引起来），布尔，字符类型（单引号括起来，内容只能有一个，例如’A’）和空类型</li>
<li>‘\t’制表符：根据前面字符串的长度，如果不够8位，补齐到8位</li>
<li>基本数据类型：<ul>
<li>整数： ，short，int，long（变量值后面加L，大小写都可以）</li>
<li>浮点数：float（变量值后面加F，大小写都可以），short</li>
<li>字符：chart</li>
</ul>
</li>
</ol>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol>
<li><p>项目结构：项目-&gt;module-&gt;包-&gt;类</p>
</li>
<li><p>类型转换</p>
<ul>
<li><p>隐式转换（自动类型提升）：小范围的类型自动提升为大范围的类型：byte &lt; short &lt; int &lt; long &lt; float &lt; double.  </p>
</li>
<li><p>强制类型转换：</p>
<ul>
<li><p>格式：目标数据类型 变量名 = （目标数据类型）被强转的数据</p>
</li>
<li><p>例如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double a = 12.3;</span><br><span class="line">int b = (int)a; </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>判断是否相等：==    判断是否不等：!=      and运算符：&amp;    or运算符：| 短路and运算符：&amp;&amp;  短路or运算符：||</p>
</li>
<li><p>键盘输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">System.out.println(&#x27;请输入值&#x27;);</span><br><span class="line">int data = sc.nextInt()</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="5">
<li><p>生成0-99的随机数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Random r = new Random()</span><br><span class="line">int number = r.nextInt(100)</span><br></pre></td></tr></table></figure></li>
<li><p>for(;;):代表无限循环</p>
</li>
<li><p>while(true):代表无限循环</p>
</li>
</ol>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol>
<li><p>定义：int [] array 或者 int array[]</p>
</li>
<li><p>静态初始化：int [] array = new int[]{1,2,3} 或者简写 int [] array = {1,2,3}</p>
</li>
<li><p>动态初始化：int [] array = new int[50]，默认数据都是0</p>
</li>
<li><p>栈：存储方法   堆：只要new出来的就存储在堆中 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		int[] arr = new int[2]</span><br><span class="line">&#125;</span><br><span class="line">main方法进栈</span><br><span class="line">int[] arr进入栈中的main方法中</span><br><span class="line">等号右边为new关键字，new出来的数组存储在堆中</span><br><span class="line">int[] arr = 地址 该地址指向堆中存储的数据</span><br></pre></td></tr></table></figure></li>
<li><p>延伸一下，何为基本数据类型，何为引用数据类型</p>
<ul>
<li>基本数据类型：数据存储在自己的空间当中，赋值给其他变量的是自己的真实的数据值。 </li>
<li>引用数据类型：使用new关键字new出来的，数据值存储在其他空间中，自己的空间中存储的是指向其他空间的地址。引用数据类型赋值给其他变量的是地址</li>
</ul>
</li>
</ol>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol>
<li><p>定义和调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void method() &#123;</span><br><span class="line">		......</span><br><span class="line">&#125;</span><br><span class="line">method()</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>带参数方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void method(int num1 , int num2) &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line">method(10,20 )</span><br></pre></td></tr></table></figure></li>
<li><p>带返回值的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int method(int a , int b) &#123;</span><br><span class="line">	int c = a + b</span><br><span class="line">  return c</span><br><span class="line">&#125;</span><br><span class="line">//返回数组</span><br><span class="line">public static int[] method() &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法的重载：同一个类中，<strong>方法名相同，参数不同的方法</strong>，就是重载。和返回值无关。</p>
<p>官方定义：多个同名的方法<strong>具有不同的参数类型和参数个数</strong>，这些同名的方法，就构成了重载关系</p>
</li>
</ol>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol>
<li><p>定义类：一个文件定义一个class类 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Phone() &#123;</span><br><span class="line">			//成员变量</span><br><span class="line">			String brand;</span><br><span class="line">			double price;</span><br><span class="line">			//成员方法</span><br><span class="line">			public void call()&#123;</span><br><span class="line">					system.out.println(&#x27;&#x27;)</span><br><span class="line">			&#125;</span><br><span class="line">			public void playGame() &#123;</span><br><span class="line">			 		........</span><br><span class="line">			&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建手机对象并使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //创建对象</span><br><span class="line">Phone p = new Phone();</span><br><span class="line">//使用</span><br><span class="line">p.brand = &#x27;小米&#x27;</span><br><span class="line">.........</span><br></pre></td></tr></table></figure></li>
<li><p>用来描述一类事物的类不用写main方法，像上面的Phone类，这种类叫做<strong>javabean</strong>类 </p>
<ul>
<li>标准的javabean类<ul>
<li>见名知意</li>
<li>成员变量使用private关键字，通过get ，set访问</li>
<li>提供至少两个构造方法<ol>
<li>无参构造</li>
<li>带全部参数的构造</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>封装：告诉你如何正确的设计对象的属性和方法</p>
</li>
<li><p>针对private的成员变量，需要提供get和set方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GirlFriend() &#123;</span><br><span class="line">			private age;</span><br><span class="line">			</span><br><span class="line">			public void setAge(a) &#123;</span><br><span class="line">				if(a &gt; 18) &#123;</span><br><span class="line">						age = a</span><br><span class="line">				&#125;</span><br><span class="line">				else &#123;</span><br><span class="line">				system.out.println(&#x27;不合法&#x27;)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			public void getAge() &#123;</span><br><span class="line">				return age</span><br><span class="line">			&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>成员变量和局部变量重名</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private int age; //0</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        int age = 18;  //18</span><br><span class="line">        System.out.println(age);  //age = 18. 就近原则</span><br><span class="line">        System.out.println(this.age) //age = 0  通过this可以访问到外部的成员变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>构造方法：  </p>
<ul>
<li>名字必须和类名相同</li>
<li>每创建一次对象（实例化），构造函数都会执行一次</li>
<li>在没写构造方法时，虚拟机默认会添加一个空参构造方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">		private string name;</span><br><span class="line">		private int age;</span><br><span class="line">		//空参构造</span><br><span class="line">		public Student() &#123;</span><br><span class="line">			........</span><br><span class="line">		&#125;</span><br><span class="line">		//带参构造</span><br><span class="line">		public student(String name , int age) &#123;</span><br><span class="line">				this.name = name;</span><br><span class="line">				this.age = age</span><br><span class="line">			.........</span><br><span class="line">		&#125;</span><br><span class="line">		get set方法.........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main函数中：</span><br><span class="line">//创建对象</span><br><span class="line">Student stu = new Student(&quot;zhangsan&quot; , 18)</span><br><span class="line">System.out.println(stu.getName());</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>对象的内存图</p>
<ol>
<li>堆内存只和new关键字有关，有new。那就是创建了一份堆空间</li>
<li>方法运行时所进入的内存为栈，变量也在这里</li>
<li>方法区中存储所有的字节码文件，也就是.class文件</li>
</ol>
<p>创建对象的步骤：</p>
<pre><code>     Student s = new Student();
     1. 加载class文件
     2. 声明局部变量
     3. 在堆内存中开辟一份空间
     4. 默认初始化
     5. 显示初始化（如果JavaBean类在声明成员变量的时候赋值了，那么就需要初始化值）
     6. 构造方法初始化
     7. 将堆内存中的地址赋值给左边的局部变量
</code></pre>
<p>代码分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">		String name;</span><br><span class="line">		int age;</span><br><span class="line"></span><br><span class="line">		public void study() &#123;</span><br><span class="line">		System.out.println(&#x27;study&#x27;);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestStudent&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Student s = new Student();</span><br><span class="line">		s.name = &quot;zs&quot;;</span><br><span class="line">		s.age = 12;</span><br><span class="line">		s.study()</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序执行：</span><br><span class="line">	先把TestStudent类加载到方法区，并临时存储main()</span><br><span class="line">	执行main函数，main方法被放入栈中</span><br><span class="line">	创建Student对象：</span><br><span class="line">		先把Student类加载到方法区中，并包含类的所有成员变量以及方法 </span><br><span class="line">		Student s被存储到栈中的main方法中</span><br><span class="line">		在堆内存中开辟一个空间，把方法区中Student.class的成员变量复制一份，并且堆中还有成员方法的地址 </span><br><span class="line">		Student s = 地址 ， 该地址为堆内存中数据的地址</span><br></pre></td></tr></table></figure>

<p>图片解析： </p>
<p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230328202415542.png"></p>
<p>两个对象的内存图：  </p>
<p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230328202745221.png" alt="image-20230328202745221"></p>
</li>
<li><p>this的原理</p>
<p><strong>前文提到的this可以访问到外部成员变量的原理：</strong>this的本质是代表方法调用者的地址值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">		String name;</span><br><span class="line">		int age;</span><br><span class="line"></span><br><span class="line">		public void study() &#123;</span><br><span class="line">		int age = 10</span><br><span class="line">		System.out.println(age);</span><br><span class="line">		System.out.println(this.age);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestStudent&#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Student s = new Student();</span><br><span class="line">		s.study()</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this指向方法的调用者，也就是s，s在被创建时值为地址，指向的就是堆内存中的数据，所以通过this.name可以获取到成员变量的值</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="快捷键使用"><a href="#快捷键使用" class="headerlink" title="快捷键使用"></a>快捷键使用</h2><ol>
<li>快速生成main方法：psvm</li>
<li>快速生成构造方法：<ul>
<li>mac快速生成快捷键 command+n。 windows快捷键：alt+insert </li>
<li>安装插件ptg ，可以快速生成空参构造，全参构造，以及get set方法</li>
</ul>
</li>
</ol>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol>
<li>在内存中，字符串存储在串池中，串池存储在堆内存中，所以字符串也是引用数据类型</li>
<li>当使用双引号<strong>直接对字符串变量赋值</strong>时系统会检查该字符串在串池中是否存在，如果不存在，就创建新的，如果存在，复用</li>
</ol>
<p>![image-20220825090504378](/Users/hetao/Library/Application Support/typora-user-images/image-20220825090504378.png)</p>
<ol start="3">
<li><p>每new一次就是开辟了一块新的 小空间，相同字符串不会复用 ，所以推荐使用直接赋值的方式，节约内存</p>
<p>![image-20220825090608673](/Users/hetao/Library/Application Support/typora-user-images/image-20220825090608673.png)</p>
</li>
<li><p>string的字符串比较方法：equals（区分大小写），equalsIgnoreCase（不区分大小写）</p>
</li>
<li><p>StringBuilder：可以看作是一个容器，创建出来后里面的吗、内容是可以变化的</p>
<p>​            使用StringBuilder的场景：字符串的拼接，字符串的反转</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建StringBuilder对象，StringBuilder既有无参构造(容器中不初始化值)，也有有参构造</span><br><span class="line">StringBuilder sb = new StringBuilder(&#x27;abc&#x27;)</span><br><span class="line">//添加元素</span><br><span class="line">sb.append(1)</span><br><span class="line">sb.append(2.3)</span><br><span class="line">sb.append(true)   输出为：abc 12.3true</span><br><span class="line">//反转</span><br><span class="line">sb.reverse()</span><br><span class="line">//把StringBuilder类型变成字符串</span><br><span class="line">String str = sb.toString()</span><br><span class="line">//打印的是sb容器中的属性，不是该引用对象的地址值，是因为java底层做的处理</span><br><span class="line">System.out.println(sb)  </span><br></pre></td></tr></table></figure></li>
<li><p>StringJoiner：和StringBuilder差不多，是个容器，里面的内容也可以变化</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建对象,StringJoiner只有有参构造，第一个参数(必选)为容器中字符串拼接的间隔符号，第二第三个参数(可选)为字符串的开始符号和结束符号</span><br><span class="line">StringJoiner sj = new StringJoiner(&quot;,&quot;,&quot;[&quot;,&quot;]&quot;)</span><br><span class="line">//添加元素</span><br><span class="line">sj.add(&quot;aaa&quot;).add(&quot;bbb&quot;).add(&quot;ccc&quot;)</span><br><span class="line">//输出为[aaa,bbb,ccc ]</span><br><span class="line">System.out.println(sj)  </span><br><span class="line">//变成字符串</span><br><span class="line">sj.toString()</span><br></pre></td></tr></table></figure>

</li>
<li><p>toString的底层方法就是new了一个字符串，带变量的字符串拼接（String a = b + “a”）底层就是先使用StringBuilder，在通过toString方法转换成字符串.所以得到的是个新地址值</p>
</li>
</ol>
<h2 id="集合ArrayList"><a href="#集合ArrayList" class="headerlink" title="集合ArrayList"></a>集合ArrayList</h2><ol>
<li><p>集合：</p>
<ol>
<li><p>长度是动态遍变化的，自动伸缩</p>
</li>
<li><p>存引用数据类型，如果要存基本数据类型，需要把他们变成对应的包装类 </p>
</li>
<li><p>使用：&lt;&gt;代表泛型，用来限制数据类型</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;()</span><br><span class="line">System.out,println(list)   //[]</span><br></pre></td></tr></table></figure></li>
<li><p>ArrayList是java已经写好的一个类，这个类在底层做了处理，打印的不是地址值，是集合中存储的数据类型。在展示的时候数据会用[ ] 包起来。</p>
</li>
<li><p>ArrayList方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean add(E e)							//添加元素，返回值表示是否添加成功</span><br><span class="line">boolean remove(E e)						//删除元素，返回值表示是否成功</span><br><span class="line">E remove(int index)						//删除指定索引的元素，返回值为被删除的元素</span><br><span class="line">E set(int index , E e)				//修改指定索引的元素，返回原来的元素</span><br><span class="line">E get(int index)							//获得指定索引的元素</span><br><span class="line">int size()										//集合中元素的个数 </span><br></pre></td></tr></table></figure></li>
<li><p>集合中存放自定义类型的数据</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义了一个Student的javaBean类</span><br><span class="line">public class Student() &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line">	</span><br><span class="line">	.........</span><br><span class="line">	get/set方法</span><br><span class="line">	空参构造和全参构造</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;()</span><br><span class="line"></span><br><span class="line">Student s1 = new Student(&quot;张三&quot;, 18)</span><br><span class="line">list.add(s1)</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><ol>
<li><p>static关键字，用来修饰成员变量或者成员方法，被static修饰的成员变量被所有实例对象共享</p>
<figure class="highlight plaintext"><figcaption><span>s</span></figcaption><table><tr><td class="code"><pre><span class="line">//被static修饰的成员变量</span><br><span class="line">public class Student&#123;</span><br><span class="line">	.......其他私有成员变量.........</span><br><span class="line">	static String teacherName;</span><br><span class="line">	.......get/set方法以及成员方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在主函数中（主函数也叫测试类）</span><br><span class="line">main()&#123;</span><br><span class="line">	//该属性被所有Student类的实例对象共享</span><br><span class="line">	Student.teacherName = &quot;张三&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>static修饰的方法一般写在工具类中，何为工具类？就是帮忙处理功能的类，比如：可以求最大值的工具类，求平均值的工具类，工具类中的构造方法是私有化的，目的为不让外界实例化他的对象，他里面的方法需要定义为static的，方便调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AverageUtil()&#123;</span><br><span class="line">	private AverageUtil() &#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	public staic int Average(int[] arr )&#123;</span><br><span class="line">		//里面写功能</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="3">
<li>静态方法中没有this关键字,普通函数的this指向调用它的对象，而static方法中没有this，所以会报错</li>
</ol>
<p>  <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230328195427351.png" alt="image-20230328195427351"></p>
<ol start="4">
<li>静态方法中不能访问非静态的东西，也就是不能访问非静态方法和非静态变量，在如下的JavaBean类中,method方法为静态方法，其不能访问name和age两个非静态变量，主要原因还是因为其没有this，不知道是哪个对象的name和age。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qianrui.staticUse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String teacherName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Student <span class="built_in">this</span>)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age + <span class="string">&quot;,&quot;</span> + teacherName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在内存方面，静态的东西随着着类的加载而加载，非静态的东西和对象有关，只要没创建对象，非静态的东西就不会被加载到内存中。</li>
</ol>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li>使用extends继承</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>java只支持单继承，也就是一个儿子只能有一个父亲，不支持多继承，但是支持多重继承。</p>
</li>
<li><p>每一个类都直接或间接继承于Object类，默认继承。</p>
</li>
<li><p>子类只能访问父类非私有的成员</p>
</li>
<li><p>子类能继承父类中的哪些内容：</p>
</li>
<li><p>构造方法 非私有的不能继承，私有不能继承：因为如果可以继承父类的构造方法，那会导致构造方法和类名不相同。</p>
</li>
<li><p>成员变量 非私有能继承，私有能继承：虽然可以继承父类私有的成员变量，但是不能使用。</p>
</li>
<li><p>成员方法 非私有能继承，私有不能继承：java会在最顶层的父类设置一个虚方法表（非private方法，非static方法，非final方法），将自己的虚方法存放在虚方法表中，继承其的子类会继承其虚方法表，并在其中添加自己的虚方法，所以使用子类中没有的方法时，并不是一层一层往父类上找，而是先查询虚方法表，如果没有再一层一层往上找。</p>
</li>
<li><p>继承的内存图如下所示，在加载子类的字节码文件时，也会将父类的字节码文件加载进方法区</p>
</li>
</ol>
<p>  <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230405140020717.png" alt="image-20230405140020717"></p>
<p>  <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230405141227208.png" alt="image-20230405141227208"></p>
<ol start="10">
<li><p>继承中成员变量，成员方法，构造方法的访问特点：</p>
<ol>
<li>成员变量：就近原则，如果没有重名的成员变量，就直接通过名字访问，如果重名，则要访问本类的，使用this，访问父类的使用super。</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">father</span>()&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;father&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">son</span> <span class="keyword">extends</span> <span class="title class_">father</span>() &#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;son&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;temp&#x27;</span>;           </span><br><span class="line">		System.out.println(name);           <span class="comment">//temp  就近原则</span></span><br><span class="line">		System.out.println(<span class="built_in">this</span>.name);      <span class="comment">//son   this访问本类成员变量</span></span><br><span class="line">		System.out.println(<span class="built_in">super</span>.name);     <span class="comment">//father super代表父类的变量或方法</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>成员方法：就近原则，和成员变量访问特点一样。当子类成员方法中的名字和父类成员方法中的名字相同，那就是重写，重写需要写@Override注解（注释是给程序员看的，注释是给虚拟机看得），校验子类重写时语法是否正确。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> <span class="title class_">father</span>()&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">son</span> <span class="keyword">extends</span> <span class="title class_">father</span>() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		System.oput.println(<span class="string">&quot;eat food&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>方法重写的原理：B类继承C类的虚方法表，重写method2方法，那么method2方法就属于B的，A继承的虚方法表中的method2为B的method2</p>
<p> <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230406155825377.png" alt="image-20230406155825377"></p>
</li>
<li><p>重写方法的要求：</p>
<ol>
<li><p>重写的方法名称，形参列表必须与父类中的一致</p>
</li>
<li><p>重写方法的访问权限和返回值类型尽量与父类保持一致</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写方法时，子类的返回值类型大于父类，就会报错，Animal&gt;Dog（范围）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Animals <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>只有添加到虚方法表中的方法才能被重写</p>
</li>
</ol>
</li>
<li><p>构造方法：子类中的构造方法默认先访问父类中的构造方法，再执行自己的，原因是子类在初始化的时候可能会用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据，所以子类在初始化之前先调用父类的构造方法来完成父类数据空间的初始化。因此子类构造方法的第一句就是super(),不写也存在，且必须在第一行，想调用父类的有参构造，必须手写super进行调用传参。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;父类无参&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认super()</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;子类无参&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     	<span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();    <span class="comment">//控制台会先输出父类无参，再输出子类无参</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;父类无参&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认super()</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;子类无参&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(name , age);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//想要创建学生对象的时候初始化值，就要在Student的有参构造中手动调用super传参</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;zs&#x27;</span> , <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><p>this(…)可以访问构造方法，代码如下所示,测试类中调用的无参构造，想要实现如果不赋值，默认名字为张三，则在Student的无参构造中调用有参构造，并赋默认值张三。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;张三&quot;</span>, <span class="literal">null</span>)</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(name , age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     	<span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();  </span><br><span class="line">        System.out.println(st.name); <span class="comment">//张三</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230406164746854.png" alt="image-20230406164746854"></p>
</li>
</ol>
<p>​            </p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol>
<li><p>多态的前提：（1）有继承关系（2）有父类引用子类对象，类似于Father f = new Son()（3）有方法重写</p>
</li>
<li><p>多态的好处：使用父类型作为参数，可以接受所有子类对象，提现多态的扩展性与便利</p>
</li>
<li><p>多态中调用成员方法，变量的特点：</p>
<ol>
<li>调用成员变量：编译看左边，运行也看左边</li>
<li>调用成员方法：编译看左边，运行看右边</li>
<li>编译看左边导致多态不能调用子类的特有方法</li>
</ol>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态使用</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//编译看左边，javac编译代码时，会看左边的父类中有没有这个变量，如果有编译成功，如果没有编译失败</span></span><br><span class="line">        <span class="comment">//运行看左边：多条使用语句Animal a = new Dog();中左边是Animal，所以输出为动物</span></span><br><span class="line">        System.out.println(a.name);<span class="comment">//动物</span></span><br><span class="line">        <span class="comment">//运行看右边：多条使用语句Animal a = new Dog();中左边是Dog，所以输出为狗方法</span></span><br><span class="line">        a.method();<span class="comment">//狗方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;猫&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ol>
<li>包就是文件夹，包名规则：公司域名+包的作用</li>
<li>使用同一包中的类不需要导包</li>
<li>使用java.lang包不需要导包</li>
<li>其他情况需要导包</li>
<li>如果同时使用两个包中的同名类，需要使用全类名（包名+类名）</li>
</ol>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ol>
<li><p>用final修饰方法：该方法是最终方法，不能被重写</p>
</li>
<li><p>用final修饰类：该类是最终类，不能被继承</p>
</li>
<li><p>用final修饰变量：叫做常量，只能被赋值一次，final修饰的是基本数据类型，那么变量存储的数据值不能发生改变，如果修饰的变量是引用数据类型，那么存储的地址值不可以发生改变，对象内部可以发生改变。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] ARR = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">ARR[<span class="number">0</span>] = <span class="number">4</span>; <span class="comment">//不会报错</span></span><br><span class="line">ARR = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]; <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230420145823174.png" alt="image-20230420145823174"></p>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ol>
<li><p>抽象类的作用：当一个父类的两个子类有共同的一个方法，但是方法内容不一样，此时可以在子类中进行方法的重写，但是如果子类的代码不是自己写，而是别人写，别人忘了重写，就会导致子类的该方法与实际不符，所以可以在父类中将该方法定义为抽象方法，这样子类就必须进行重写，不重写就会报错。包含抽象方法的类称为抽象类。</p>
</li>
<li><p>抽象方法：子类共同的方法名，但是方法体不一样，在父类中，这种方法可以称为抽象方法。</p>
</li>
<li><p>抽象方法定义格式：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表)</span><br></pre></td></tr></table></figure></li>
<li><p>抽象类：一个类中存在抽象方法，则该类必须声明为抽象类。</p>
</li>
<li><p>抽象类定义格式</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>抽象类注意事项：</p>
<ol>
<li><p>抽象类不能实例化，也就是Person p = new Person();会报错</p>
</li>
<li><p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</p>
</li>
<li><p>抽象类可以有构造方法，作用是当创建子类对象时，给子类对象赋值的,因为虽然父类不能实例化，但是子类如果不是抽象类，是可以实例化的，需要给子类的实例化对象进行赋值。</p>
</li>
</ol>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">	String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name , <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    pubic <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">    get/set...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name , age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zs&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        System.out.println(s.getName() + <span class="string">&#x27;&#x27;</span> + s.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>抽象类的子类：要么重写抽象类中的所有抽象方法，要么是抽象类</li>
</ol>
</li>
</ol>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol>
<li>比如父类为动物类，子类为兔子，狗和青蛙，狗和青蛙有一个公共属性游泳，但是这个属性不能写入父类中，因为不是公共的方法。但是如果各自写入子类当中，就不能规范书写的格式，所以需要定义一个接口来实现。</li>
</ol>
<p>  <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230425132849866.png" alt="image-20230425132849866"></p>
<ol start="2">
<li><p>接口就是一种规则，是对行为的抽象。</p>
</li>
<li><p>接口的定义和使用：</p>
</li>
<li><p>接口使用interface来定义：public interface 接口名 {}</p>
</li>
<li><p>接口不能实例化    </p>
</li>
<li><p>接口和类之间是实现关系，通过implements关键字表示：public class 类名 implements 接口名 {}</p>
</li>
<li><p>类中需要重写接口中的所有抽象方法（类中也要重写父类中的所有抽象方法）</p>
</li>
<li><p>接口和类的实现关系可以单实现，也可以多实现：public 类名 implements 接口名1，接口名2 {}</p>
</li>
<li><p>当类中实现的多个接口中有重名的抽象方法，只需要重写一次即可。</p>
</li>
<li><p>实现类还可以再继承一个类的同时实现多个接口：public 类名 extends 父类 implements 接口名1，接口名2 {}</p>
</li>
<li><p>接口与接口也可以继承，可以单继承，也可以多继承（类不能多继承，只能多层继承）</p>
</li>
<li><p>代码示例见 ``package com.qianrui.interfaceTest` 包。</p>
</li>
<li><p>接口中成员的特点：</p>
</li>
<li><p>成员变量:只能是常量,默认修饰符：public static final</p>
</li>
<li><p>构造方法:没有构造方法</p>
</li>
<li><p>成员方法:只能是抽象方法,默认修饰符：public abstract</p>
</li>
<li><p>JDK7以前只能接口中只能定义抽象方法，JDK8之后接口中可以定义有方法体的方法，包括静态方法和默认方法，主要是为了解决接口升级的问题,默认方法格式如下，默认方法注意事项：</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名(参数列表) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>该方法不是抽象方法，不强制重写，如果被重写，重写时去掉default关键字</p>
</li>
<li><p>public可以省略，default不能省略，如果省略了default，默认是抽象方法，抽象方法不能有方法体</p>
</li>
<li><p>如果实现了多个接口，多个接口中存在相同名字的默认方法，实现类就必须对该方法进行重写</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//接口1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImp</span> <span class="keyword">implements</span> <span class="title class_">InterA</span>,InterB &#123;</span><br><span class="line">    <span class="comment">//不重写就会报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">InterImp</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterImp</span>();</span><br><span class="line">        ii.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>​<br>​    ```</p>
<ol start="7">
<li> 静态方法，静态方法不能重写</li>
</ol>
<p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230425163912249.png" alt="image-20230425163912249"></p>
<ol start="8">
<li>JDK9以后新增了私有方法：主要是抽取默认方法或者静态方法中的一些公共代码，格式一是为默认方法服务的，格式二是为静态方法服务的</li>
</ol>
<p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230425164255107.png" alt="image-20230425164255107"></p>
<ol start="9">
<li><p>接口适配器:当一个接口中有多个方法，我们需要使用其中的一个方法，却需要重写所有抽象方法，不容易一眼看到想要的方法，所以设计接口适配器，在接口适配器中重写所有方法，然后使用实现类继承适配器，重写所需要的方法即可。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method6</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器写为抽象类是为了不让外界创建他的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> implement inter &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//重写method1-method5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol>
<li><p>在类的里面定义的类称为内部类，内部类表示的事物是外部类的一部分，内部类单独出现没有任何意义</p>
</li>
<li><p>内部类的访问特点：（1）内部类可以直接访问外部类的成员，包括私有。（2）外部类要访问内部类的成员必须创建对象</p>
</li>
<li><p>包括：成员内部类，静态内部类(JDK16之后)，局部内部类，匿名内部类</p>
</li>
<li><p>成员内部类</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;	外部类</span><br><span class="line">	string carName;</span><br><span class="line">	<span class="type">int</span> carAge;</span><br><span class="line">	<span class="type">int</span> carcolor;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Engine</span>&#123;	成员内部类</span><br><span class="line">		string engineName;</span><br><span class="line">		<span class="type">int</span> engineAge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>获取成员内部类的对象</p>
</li>
<li><p>方法一：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;	外部类</span><br><span class="line">	string carName;</span><br><span class="line">	<span class="type">int</span> carAge;</span><br><span class="line">	<span class="type">int</span> carcolor;</span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Engine</span>&#123;	成员内部类</span><br><span class="line">		string engineName;</span><br><span class="line">		<span class="type">int</span> engineAge;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Car.<span class="type">Engine</span> <span class="variable">en</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>().<span class="keyword">new</span> <span class="title class_">Engine</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>方法二：外部类中编写方法，对外提供内部类对象。这种方法当内部类是私有的时候也可以用，上面的方法则不可以。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;	外部类</span><br><span class="line">	string carName;</span><br><span class="line">	<span class="type">int</span> carAge;</span><br><span class="line">	<span class="type">int</span> carcolor;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;	成员内部类</span><br><span class="line">		string engineName;</span><br><span class="line">		<span class="type">int</span> engineAge;</span><br><span class="line">	&#125;</span><br><span class="line">                  </span><br><span class="line">     <span class="keyword">public</span> Engine <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Engine</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        c.getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230428193648326.png" alt="image-20230428193648326"></p>
</li>
<li><p>静态内部类：只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;	外部类</span><br><span class="line">	string carName;</span><br><span class="line">	<span class="type">int</span> carAge;</span><br><span class="line">	<span class="type">int</span> carcolor;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;	静态内部类</span><br><span class="line">		string engineName;</span><br><span class="line">		<span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            sout(<span class="string">&quot;非静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">show1</span><span class="params">()</span> &#123;</span><br><span class="line">            sout(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">        &#125;             </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>静态内部类</p>
</li>
<li><p>创建静态内部类对象的格式：外部类名.内部类名 对象名 = new 外部类名.内部类名()</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       Car.<span class="type">Engine</span> <span class="variable">en</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>.Engine();</span><br><span class="line">        en.show();</span><br><span class="line">        en.show1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用非静态方法的格式：先创建对象，用对象调用</p>
</li>
<li><p>调用静态方法的格式：外部类名.内部类名.方法名()</p>
</li>
<li><p>局部内部类：定义在方法里面的类称为局部内部类，外界无法使用局部内部类，类似于局部变量，该类可以直接访问外部类的成员，也可以访问方法内的局部变量。</p>
</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Outer&#123; 外部类</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Inner</span>&#123; 局部内部类</span><br><span class="line">            String name;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">    <span class="comment">//创建局部内部类的对象</span></span><br><span class="line">    <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    sout(in.name)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>匿名内部类：隐藏了名字的内部类</li>
</ol>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">new</span> 类名或者接口名() &#123;</span><br><span class="line">	重写方法；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">             sout(<span class="string">&quot;重写了swim方法&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="10">
<li><p>匿名内部类使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在测试类中调用method方法，之前的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">		sout(<span class="string">&quot;吃骨头&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        method(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上面的书写方式有点麻烦，使用匿名内部类书写如下,不用再单独定义一个Dog类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(</span><br><span class="line">        	<span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">				<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">				sout(<span class="string">&quot;吃骨头&quot;</span>)</span><br><span class="line">				&#125;</span><br><span class="line">            &#125;</span><br><span class="line">       	);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>匿名内部类格式细节：包含了继承和实现，方法重写，创建对象</p>
</li>
<li><p>匿名内部类使用场景：当方法的参数是接口或者类时，如上例子所示</p>
</li>
</ol>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Yang Wa</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/11/03/java/">http://example.com/2022/11/03/java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a><a class="post-meta__tags" href="/tags/java/">java</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2022/11/07/%E4%BD%95%E4%B8%BACDN/"><i class="fa fa-chevron-left">  </i><span>何为CDN</span></a></div><div class="next-post pull-right"><a href="/2022/10/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B1%BB%E9%97%AE%E9%A2%98/"><span>动态规划类问题</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'http://example.com/2022/11/03/java/';
  this.page.identifier = '2022/11/03/java/';
  this.page.title = 'java学习基础';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'boji' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://boji.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/731-2.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2022 - 2023 By Yang Wa</div><div class="framework-info"><span>Driven - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>