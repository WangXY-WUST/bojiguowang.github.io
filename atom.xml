<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yang Wa</title>
  
  <subtitle>Who killed me, and I killed who</subtitle>
  <link href="https://blog.wxywxy.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.wxywxy.cn/"/>
  <updated>2023-08-13T07:38:51.083Z</updated>
  <id>https://blog.wxywxy.cn/</id>
  
  <author>
    <name>Yang Wa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ThreeJS</title>
    <link href="https://blog.wxywxy.cn/2023/08/05/ThreeJS/"/>
    <id>https://blog.wxywxy.cn/2023/08/05/ThreeJS/</id>
    <published>2023-08-05T01:31:13.000Z</published>
    <updated>2023-08-13T07:38:51.083Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h2><ol><li><p>一个动画被创建有三个基本要素: 场景、相机、物体</p><p>所以接下来,先创建一个动画主要有以下几个步骤</p><ol><li>建立场景</li><li>定义相机，相机可以理解为我们看的视角<ol><li>设置相机位置</li><li>添加相机到场景</li></ol></li><li>创建物体<ol><li>创建几何体</li><li>定义几何体的材质</li><li>通过网格对象Mesh创建物体</li><li>将物体添加到场景中</li></ol></li><li>开始渲染<ol><li>初始化渲染器</li><li>设置渲染尺寸大小</li><li>初始化的渲染器中会生成一个canvas节点，将该节点添加到body中</li><li>通过渲染器渲染场景和相机</li></ol></li><li>结束</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="variable constant_">THREE</span> <span class="keyword">from</span> <span class="string">&#x27;three&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立场景</span></span><br><span class="line"><span class="keyword">const</span> scene = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Scene</span>()</span><br><span class="line"><span class="comment">// 定义一个相机</span></span><br><span class="line"><span class="keyword">const</span> camera = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">PerspectiveCamera</span>(<span class="number">75</span>, <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span>, <span class="number">0.1</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 设置相机位置</span></span><br><span class="line">camera.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 添加相机到场景</span></span><br><span class="line">scene.<span class="title function_">add</span>(camera)</span><br><span class="line"><span class="comment">// 定义几何体</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BoxGeometry</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 定义材质</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;)</span><br><span class="line"><span class="comment">// 根据材质和几何创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material)</span><br><span class="line"><span class="comment">// 将物体添加到场景中</span></span><br><span class="line">scene.<span class="title function_">add</span>(cube)</span><br><span class="line"><span class="comment">// 初始化渲染器</span></span><br><span class="line"><span class="keyword">const</span> renderer = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">WebGL1Renderer</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(renderer)</span><br><span class="line"><span class="comment">// 设置渲染尺寸大小</span></span><br><span class="line">renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br><span class="line"><span class="comment">// webgl会渲染会生成一个canvas节点,将节点添加到body中</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(renderer.<span class="property">domElement</span>)</span><br><span class="line"><span class="comment">// 渲染相机和场景</span></span><br><span class="line">renderer.<span class="title function_">render</span>(scene, camera)</span><br></pre></td></tr></table></figure></li></ol><h2 id="轨道控制器"><a href="#轨道控制器" class="headerlink" title="轨道控制器"></a>轨道控制器</h2><ol><li><p>轨道控制器的作用就是可以使我们以3D视角拖动查看创建的动画，相当于一个卫星轨道</p></li><li><p>轨道控制器OrbitControls主要传递两个参数：哪个相机，围绕哪个物体。</p></li><li><p>如果不每一帧都重新渲染的话，页面就是静态的，所以使用requestAnimationFrame，每一帧就调用一次render</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">OrbitControls</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/controls/OrbitControls.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line">代码块<span class="number">1</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">const</span> control = <span class="keyword">new</span> <span class="title class_">OrbitControls</span>(camera, renderer.<span class="property">domElement</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">render</span> () &#123;</span><br><span class="line"><span class="comment">// 渲染相机和场景</span></span><br><span class="line">renderer.<span class="title function_">render</span>(scene, camera)</span><br><span class="line">  <span class="title function_">requestAnimationFrame</span>(render)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>()</span><br></pre></td></tr></table></figure></li></ol><h2 id="辅助坐标系"><a href="#辅助坐标系" class="headerlink" title="辅助坐标系"></a>辅助坐标系</h2><ol><li><p>效果就是有一个三维坐标系</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5代表长度</span></span><br><span class="line"><span class="keyword">const</span> axesHelper = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">AxesHelper</span>(<span class="number">5</span>)</span><br><span class="line">scene.<span class="title function_">add</span>(axesHelper)</span><br></pre></td></tr></table></figure></li></ol><h2 id="物体移动"><a href="#物体移动" class="headerlink" title="物体移动"></a>物体移动</h2><ol><li><p>之前通过Mash创建的物体cube，在控制台输出如下，其中position控制物体移动，scale控制物体缩放，rotation控制物体旋转</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230805113314729.png" alt="cube属性"></p></li><li><p>使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//移动</span></span><br><span class="line">cube.<span class="property">position</span>.<span class="title function_">set</span>(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">or</span><br><span class="line">cube.<span class="property">position</span>.<span class="property">x</span> = <span class="number">1</span></span><br><span class="line">cube.<span class="property">position</span>.<span class="property">y</span> = <span class="number">1</span></span><br><span class="line">cube.<span class="property">position</span>.<span class="property">z</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//缩放</span></span><br><span class="line">cube.<span class="property">scale</span>.<span class="title function_">set</span>(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">or</span><br><span class="line">cube.<span class="property">scale</span>.<span class="property">x</span> = <span class="number">1</span></span><br><span class="line">cube.<span class="property">scale</span>.<span class="property">y</span> = <span class="number">1</span></span><br><span class="line">cube.<span class="property">scale</span>.<span class="property">z</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">//旋转</span></span><br><span class="line">cube.<span class="property">rotation</span>.<span class="title function_">set</span>(<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>)</span><br><span class="line">or</span><br><span class="line">cube.<span class="property">rotation</span>.<span class="property">x</span> = <span class="number">1</span></span><br><span class="line">cube.<span class="property">rotation</span>.<span class="property">y</span> = <span class="number">1</span></span><br><span class="line">cube.<span class="property">rotation</span>.<span class="property">z</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><h3 id="自适应屏幕"><a href="#自适应屏幕" class="headerlink" title="自适应屏幕"></a>自适应屏幕</h3><ol><li><p>当屏幕大小拉伸时,可以自适应屏幕</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画布自适应窗口</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 重置渲染器宽高比</span></span><br><span class="line">  renderer.<span class="title function_">setSize</span>(<span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="variable language_">window</span>.<span class="property">innerHeight</span>)</span><br><span class="line">  <span class="comment">// 重置相机宽高比</span></span><br><span class="line">  camera.<span class="property">aspect</span> = <span class="variable language_">window</span>.<span class="property">innerWidth</span> / <span class="variable language_">window</span>.<span class="property">innerHeight</span></span><br><span class="line">  <span class="comment">// 更新相机投影矩阵</span></span><br><span class="line">  camera.<span class="title function_">updateProjectionMatrix</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="线框模式"><a href="#线框模式" class="headerlink" title="线框模式"></a>线框模式</h3><ol><li><p>线框模式通过两种方式设置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义材质</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;)</span><br><span class="line"><span class="comment">//设置线框</span></span><br><span class="line">material.<span class="property">wireframe</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span> &#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>效果图</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230813150522353.png" alt="线框模式关闭"></p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230813150658567.png" alt="线框模式开启"></p></li></ol><h3 id="形状绘制"><a href="#形状绘制" class="headerlink" title="形状绘制"></a>形状绘制</h3><ol><li><p>之前使用的都是THREEJS自带的几何体,现在来手绘几何体,从上图的线框模式可以看出,其实基本的形状就是三角形,所以先绘制三角形.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="comment">//定义几何体,缓冲几何体是所有几何体的基类</span></span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>()</span><br><span class="line"><span class="comment">//建立顶点</span></span><br><span class="line"> <span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([-<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>])</span><br><span class="line"> <span class="comment">//创建顶点属性,vertices代表顶点数组,3代表三个一组</span></span><br><span class="line">geometry.<span class="title function_">setAttribute</span>(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(vertices, <span class="number">3</span>))</span><br><span class="line"><span class="comment">//定义材质</span></span><br><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span>, <span class="attr">wireframe</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="comment">// 根据材质和几何创建物体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry, material)</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230813151352978.png" alt="三角形绘制"></p></li><li><p>顶点是有顺序的.逆时针写为正面,顺时针写为反面,当你的顶点是以逆时针写的,那么在反面就看不到图形,想要两面都显示,设置material的side属性即可.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> material = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span>, <span class="attr">side</span>: <span class="variable constant_">THREE</span>.<span class="property">DoubleSide</span>, <span class="attr">wireframe</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure></li><li><p>绘制矩形的话就是将顶点数据进行完善</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">  -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, </span><br><span class="line">  -<span class="number">1.0</span>,-<span class="number">1.0</span>, <span class="number">0.0</span>, -<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>])</span><br></pre></td></tr></table></figure><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230813151759409.png" alt="矩形"></p></li></ol><h3 id="顶点索引"><a href="#顶点索引" class="headerlink" title="顶点索引"></a>顶点索引</h3><ol><li><p>在上面的矩形中,输出<code>geometry</code> ,其中count为6代表顶点数为6,代表自己手写的顶点数,其中有许多是重复写的,可以使用顶点索引来减少代码量</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230813151917410.png" alt="geometry"></p></li><li><p>顶点索引就是建立顶点的时候就是只写自己需要的顶点,不用重复写</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">const</span> geometry = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferGeometry</span>()</span><br><span class="line"><span class="comment">//建立顶点</span></span><br><span class="line"><span class="keyword">const</span> vertices = <span class="keyword">new</span> <span class="title class_">Float32Array</span>([</span><br><span class="line">  -<span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, -<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, </span><br><span class="line">  -<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>])</span><br><span class="line"><span class="comment">// 创建顶点属性</span></span><br><span class="line">geometry.<span class="title function_">setAttribute</span>(<span class="string">&#x27;position&#x27;</span>, <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(vertices, <span class="number">3</span>))</span><br><span class="line"><span class="comment">//  构建索引,数组中的索引为也是三个为一组,为vertices的索引值</span></span><br><span class="line"><span class="keyword">const</span> indices = <span class="keyword">new</span> <span class="title class_">Uint16Array</span>([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>])</span><br><span class="line"><span class="comment">// 设置索引</span></span><br><span class="line">geometry.<span class="title function_">setIndex</span>(<span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">BufferAttribute</span>(indices, <span class="number">1</span>))</span><br><span class="line"><span class="comment">//定义材质</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure></li><li><p>输出<code>geometry</code></p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230813152545919.png" alt="geomerty"></p></li></ol><h3 id="几何体分组渲染"><a href="#几何体分组渲染" class="headerlink" title="几何体分组渲染"></a>几何体分组渲染</h3><ol><li><p>可以看出,三角形属于基本图形,所以我们可以对一个正方形的每个三角形进行不同的渲染材质,展示不同的效果</p></li><li><p>实现</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义几何体</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//建立顶点,创建顶点属性,构建索引,设置索引</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">//设置两个顶点组,形成两个材质,第一个参数代表从索引几开始,第二个参数代表索引到几结束,第三个参数代表使用第几个材质</span></span><br><span class="line">geometry.<span class="title function_">addGroup</span>(<span class="number">0</span>,<span class="number">3</span>,<span class="number">0</span>)</span><br><span class="line">geometry.<span class="title function_">addGroup</span>(<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">//定义两个材质</span></span><br><span class="line"><span class="keyword">const</span> material1 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0x00ff00</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> material2 = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">MeshBasicMaterial</span>(&#123; <span class="attr">color</span>: <span class="number">0xff0000</span>&#125;)</span><br><span class="line"><span class="comment">//创建几何体</span></span><br><span class="line"><span class="keyword">const</span> cube = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Mesh</span>(geometry , [material1 , material2 ])</span><br><span class="line">....</span><br></pre></td></tr></table></figure></li><li><p>效果</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230813153054549.png" alt="分组渲染"></p></li></ol><h2 id="lil-gui"><a href="#lil-gui" class="headerlink" title="lil-gui"></a>lil-gui</h2><ol><li><p>lil-gui是一个图形化操作界面,方便我们对物体进行操作</p></li><li><p>代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">GUI</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;three/examples/jsm/libs/lil-gui.module.min.js&#x27;</span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">const</span> gui = <span class="keyword">new</span> <span class="title function_">GUI</span>()</span><br><span class="line"><span class="comment">//定义两个对象,一个是全屏,一个是退出全屏</span></span><br><span class="line"><span class="keyword">let</span> event = &#123;</span><br><span class="line">  <span class="title class_">FullScreen</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">requestFullscreen</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">exitScreen</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">exitFullscreen</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将这两个对象添加到gui当中</span></span><br><span class="line">gui.<span class="title function_">add</span>(event,<span class="string">&#x27;FullScreen&#x27;</span>)</span><br><span class="line">gui.<span class="title function_">add</span>(event, <span class="string">&#x27;exitScreen&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>效果,在右上角显示如下,点击就可以实现全屏个退出全屏的效果</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230813153516200.png" alt="gui初用"></p></li><li><p>不仅如此,还可以对物体的位置进行操作</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 控制cube位置 , addFolder就是一个新建一个文件夹,向里面添加属性,文件夹下的属性就以一个下拉菜单的形式展示</span></span><br><span class="line"><span class="keyword">let</span> folder = gui.<span class="title function_">addFolder</span>(<span class="string">&quot;立方体位置&quot;</span>)</span><br><span class="line"><span class="comment">//两种书写方式,第一种,name代表别名,onChange时当位置改变时的回调</span></span><br><span class="line">folder.<span class="title function_">add</span>(cube.<span class="property">position</span>, <span class="string">&#x27;x&#x27;</span>, -<span class="number">5</span>, <span class="number">5</span>).<span class="title function_">name</span>(<span class="string">&#x27;x位置&#x27;</span>).<span class="title function_">onChange</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//第二种,min代表移动的最小值,max代表移动的最大值,step代表每次移动的步数,onFinishChange代表你说鼠标移开屏幕时的回调</span></span><br><span class="line">folder.<span class="title function_">add</span>(cube.<span class="property">position</span>, <span class="string">&#x27;y&#x27;</span>).<span class="title function_">min</span>(-<span class="number">10</span>).<span class="title function_">max</span>(<span class="number">10</span>).<span class="title function_">step</span>(<span class="number">1</span>).<span class="title function_">name</span>(<span class="string">&#x27;y位置&#x27;</span>).<span class="title function_">onFinishChange</span>(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123; </span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value)</span><br><span class="line">&#125;)</span><br><span class="line">folder.<span class="title function_">add</span>(cube.<span class="property">position</span>, <span class="string">&#x27;z&#x27;</span>).<span class="title function_">min</span>(-<span class="number">10</span>).<span class="title function_">max</span>(<span class="number">10</span>).<span class="title function_">step</span>(<span class="number">1</span>).<span class="title function_">name</span>(<span class="string">&#x27;z位置&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>效果</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230813153840559.png" alt="位置效果"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;入门使用&quot;&gt;&lt;a href=&quot;#入门使用&quot; class=&quot;headerlink&quot; title=&quot;入门使用&quot;&gt;&lt;/a&gt;入门使用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;一个动画被创建有三个基本要素: 场景、相机、物体&lt;/p&gt;
&lt;p&gt;所以接下来,先创建一个动画主要有以下几个步</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="动画" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E5%8A%A8%E7%94%BB/"/>
    
    <category term="ThreeJS" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E5%8A%A8%E7%94%BB/ThreeJS/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="动画" scheme="https://blog.wxywxy.cn/tags/%E5%8A%A8%E7%94%BB/"/>
    
    <category term="ThreeJS" scheme="https://blog.wxywxy.cn/tags/ThreeJS/"/>
    
  </entry>
  
  <entry>
    <title>Pinia:Vue的状态管理库</title>
    <link href="https://blog.wxywxy.cn/2023/07/31/Pinia-Vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93/"/>
    <id>https://blog.wxywxy.cn/2023/07/31/Pinia-Vue%E7%9A%84%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%BA%93/</id>
    <published>2023-07-31T02:18:26.000Z</published>
    <updated>2023-07-31T09:55:30.755Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Pinia"><a href="#什么是Pinia" class="headerlink" title="什么是Pinia"></a>什么是Pinia</h3><ul><li>Pinia是Vue的一个状态管理工具，类似于Vuex</li></ul><h3 id="为什么使用Pinia"><a href="#为什么使用Pinia" class="headerlink" title="为什么使用Pinia"></a>为什么使用Pinia</h3><ul><li>Pinia同时支持Vue2和Vue3，但是相比于Vue2，Pinia主要面对的还是Vue3用户</li><li>和Vue3一样，Pinia这个状态管理工具支持组合式API的书写方式，</li><li>如果正在开发Vue3项目，且需要使用状态管理工具，那么Pinia将是一个不错的选择</li></ul><h3 id="相比于Vuex的优势"><a href="#相比于Vuex的优势" class="headerlink" title="相比于Vuex的优势"></a>相比于Vuex的优势</h3><ol><li><p>如果使用选项式API的方式书写store中的内容，那么Pinia取消了mutation这个选项。在Vuex中主要有state，action，mutation，getter四个选项，action中主要用于发送异步请求，之后通过comiit提交给mutation，操作数据只能在mutation中进行，非常繁琐。Pinia操作数据可以在action中，并且支持同步和异步请求，相比于Vuex更加<strong style="color:#DD5145">轻量</strong>。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方实例，选项是API使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;),</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">double</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">count</span> * <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">count</span>++</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>使用组合式API，那么action相当于setup中的method，getter相当于computed，state相当于data。可以看出相比于Vuex使用的选项是API，这种书写方式更加简洁，<strong style="color:#DD5145">更适配于Vue3的特性</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//官方实例，组合式API使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useCounterStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count.<span class="property">value</span>++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; count, increment &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>一个文件里支持多个store实例，相比于Vuex更加<strong style="color:#DD5145">灵活</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第一个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useFirstStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count.<span class="property">value</span>++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; count, increment &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//第二个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useSecondStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count.<span class="property">value</span>++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; count, increment &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//第三个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useThirdStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;counter&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">ref</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">increment</span>(<span class="params"></span>) &#123;</span><br><span class="line">    count.<span class="property">value</span>++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; count, increment &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; useFirstStore,useSecondStore，useThirdStore&#125; <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li><p>安装 <code>npm i pinia</code></p></li><li><p>注册</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js中,引入createPinia</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line"><span class="comment">//实例化</span></span><br><span class="line"><span class="keyword">const</span> pinia = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="comment">//注册</span></span><br><span class="line">app.<span class="title function_">use</span>(pinia)</span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>创建store/index.js文件</p><ol><li><p>第一种使用方式（组合式API方式）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//store/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; ref &#125; <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useListNameStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;listName&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//定义state</span></span><br><span class="line">  <span class="keyword">let</span> name = <span class="title function_">ref</span>(<span class="string">&#x27;待录制列表&#x27;</span>)</span><br><span class="line">  <span class="comment">//定义action</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    name.<span class="property">value</span> = <span class="string">&quot;驳回列表&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    changeName </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//vue文件中使用</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useListNameStore &#125; from &#x27;@/store&#x27;;</span><br><span class="line">const title = useListNameStore();</span><br><span class="line">//访问state</span><br><span class="line">console.log(title.name)//待录制列表</span><br><span class="line">//访问action</span><br><span class="line">title.changeName()</span><br><span class="line">console.log(title.name)//驳回列表</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>第二种方式(选项式方式使用)</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useListNameStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;listName&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;待录制列表&quot;</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    changeName () &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&quot;驳回列表&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> title = <span class="title function_">useListNameStore</span>();</span><br><span class="line"><span class="comment">//使用state的属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(title.<span class="property">name</span>) <span class="comment">//待录制列表</span></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">title.<span class="title function_">changeName</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(title.<span class="property">name</span>) <span class="comment">//驳回列表</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li><p>上面例子中，输出<code>tite</code>，可以看出是一个Proxy对象，即是类似于reactive创造的数据，所以在读取的时候通过<code>title.name</code>即可读取，不需要通过<code>title.name.value</code>进行读取</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230731113736120.png" alt="image-20230731113736120"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是Pinia&quot;&gt;&lt;a href=&quot;#什么是Pinia&quot; class=&quot;headerlink&quot; title=&quot;什么是Pinia&quot;&gt;&lt;/a&gt;什么是Pinia&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Pinia是Vue的一个状态管理工具，类似于Vuex&lt;/li&gt;
&lt;/ul&gt;
&lt;h</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue3" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/vue3/"/>
    
    <category term="状态管理" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/vue3/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/"/>
    
    <category term="Pinia" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/vue3/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/Pinia/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue3" scheme="https://blog.wxywxy.cn/tags/vue3/"/>
    
    <category term="Pinia" scheme="https://blog.wxywxy.cn/tags/Pinia/"/>
    
  </entry>
  
  <entry>
    <title>Ionic+vue3的使用</title>
    <link href="https://blog.wxywxy.cn/2023/07/22/Ionic%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.wxywxy.cn/2023/07/22/Ionic%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2023-07-22T01:03:30.000Z</published>
    <updated>2023-07-22T11:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><h3 id="已有vue项目的情况下"><a href="#已有vue项目的情况下" class="headerlink" title="已有vue项目的情况下"></a>已有vue项目的情况下</h3><ol><li><p>执行以下命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install @ionic/vue @ionic/vue-router</span><br></pre></td></tr></table></figure></li><li><p>修改main.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">IonicVue</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@ionic/vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="title function_">use</span>(router)</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title class_">IonicVue</span>)</span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;deviceready&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>修改router’/index.js</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRouter, createWebHistory, createWebHashHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;@ionic/vue-router&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>在使用组件前，需要对每个组件进行引入并注册，例如使用一个ion-card组件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;ion-card&gt;</span><br><span class="line">    &lt;ion-card-header&gt;</span><br><span class="line">      &lt;ion-card-title&gt;Card Title&lt;/ion-card-title&gt;</span><br><span class="line">      &lt;ion-card-subtitle&gt;Card Subtitle&lt;/ion-card-subtitle&gt;</span><br><span class="line">    &lt;/ion-card-header&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ion-card-content&gt;</span><br><span class="line">      Here&#x27;s a small text description for the card content. Nothing more, nothing less.</span><br><span class="line">    &lt;/ion-card-content&gt;</span><br><span class="line">&lt;/ion-card&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">//引入组件</span><br><span class="line">import &#123;</span><br><span class="line">  IonCard,</span><br><span class="line">  IonCardContent,</span><br><span class="line">  IonCardTitle,</span><br><span class="line">  IonCardSubtitle,</span><br><span class="line">  IonCardHeader,</span><br><span class="line">&#125; from &#x27;@ionic/vue&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">   ...</span><br><span class="line">  //注册组件</span><br><span class="line">  components: &#123;</span><br><span class="line">    IonCard,</span><br><span class="line">    IonCardContent,</span><br><span class="line">    IonCardTitle,</span><br><span class="line">    IonCardSubtitle,</span><br><span class="line">    IonCardHeader,</span><br><span class="line">  &#125;,</span><br><span class="line">  setup(props, context) &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>引入样式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Ionic组件正常工作所需的核心CSS */</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@ionic/vue/css/core.css&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>接下来ionic的组件就可以正常使用</p></li></ol><h3 id="空项目的情况下"><a href="#空项目的情况下" class="headerlink" title="空项目的情况下"></a>空项目的情况下</h3><ol><li><p>全局安装ionic</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g @ionic/cli@latest</span><br></pre></td></tr></table></figure></li><li><p>创建vue程序</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ionic start my-vue-app --type vue</span><br></pre></td></tr></table></figure></li><li><p>启动程序<code>ionic serve</code></p></li><li><p>注意：node版本要大于12</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;创建项目&quot;&gt;&lt;a href=&quot;#创建项目&quot; class=&quot;headerlink&quot; title=&quot;创建项目&quot;&gt;&lt;/a&gt;创建项目&lt;/h2&gt;&lt;h3 id=&quot;已有vue项目的情况下&quot;&gt;&lt;a href=&quot;#已有vue项目的情况下&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="组件库" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
    <category term="vue3" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%BA%93/vue3/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="组件库" scheme="https://blog.wxywxy.cn/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
    <category term="vue3" scheme="https://blog.wxywxy.cn/tags/vue3/"/>
    
    <category term="ionic" scheme="https://blog.wxywxy.cn/tags/ionic/"/>
    
  </entry>
  
  <entry>
    <title>cordova使用</title>
    <link href="https://blog.wxywxy.cn/2023/07/20/cordova/"/>
    <id>https://blog.wxywxy.cn/2023/07/20/cordova/</id>
    <published>2023-07-20T03:06:12.000Z</published>
    <updated>2023-07-22T11:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><h3 id="Android环境"><a href="#Android环境" class="headerlink" title="Android环境"></a>Android环境</h3><h4 id="java环境"><a href="#java环境" class="headerlink" title="java环境"></a>java环境</h4><ol><li><p>下载JDK1.8，<a href="https://www.oracle.com/java/technologies/javase/javase8u211-later-archive-downloads.html">下载</a>，我下载其他版本的报错了，报错时提示需要1.8版本，所以建议下载JDK1.8</p></li><li><p>环境变量配置</p><ul><li>在系统变量中添加新的环境变量，变量值为JDK安装路径</li></ul><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230721102659803.png" alt="新增环境变量"></p><ul><li>Path中新增一项</li></ul><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230721102823118.png" alt="Path新增项"></p></li></ol><h4 id="Android-Studio（AS）"><a href="#Android-Studio（AS）" class="headerlink" title="Android Studio（AS）"></a>Android Studio（AS）</h4><ol><li><p>安装Android Studio，<a href="https://developer.android.google.cn/studio/">下载地址</a>，安装步骤可以网上找，大差不差的，AS会为你安装最新版的SDK，所以不用单独下载SDK，并且AS的安卓虚拟机在运行cordova时可以用到</p></li><li><p>设置安卓环境变量</p><ul><li><p>新增ANDROID_HOME，变量值为AS下载时填写的SDK地址</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230721104518963.png" alt="新增ANDROID_HOME"></p></li><li><p>编辑Path变量</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230721104637280.png" alt="编辑Path变量"></p></li></ul></li></ol><h3 id="Gradle安装"><a href="#Gradle安装" class="headerlink" title="Gradle安装"></a>Gradle安装</h3><ol><li><p><a href="https://gradle.org/releases/">下载地址</a></p></li><li><p>环境变量配置</p><ul><li><p>新增环境变量GRADLE_HOME</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230721105305722.png" alt="新增环境变量"></p></li><li><p>编辑Path</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230721105352316.png" alt="新增Path项"></p></li></ul></li></ol><h3 id="Node-git安装"><a href="#Node-git安装" class="headerlink" title="Node git安装"></a>Node git安装</h3><ol><li>这个更不用说了，直接官网下载即可，建议版本node12.22.12(因为我用的这个成功了，18版本的失败了)</li></ol><h3 id="cordova安装"><a href="#cordova安装" class="headerlink" title="cordova安装"></a>cordova安装</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g cordova@6.5.0</span><br></pre></td></tr></table></figure><h2 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h2><ol><li>运行于浏览器 <code>cordova run browser</code></li><li>运行于android虚拟机 <code>cordova build android</code> <code>cordova emulate android --verbose</code> (verbose为生成详细日志输出)</li><li>查看当前cordova android版本 <code>cordova platform version android</code></li><li>升级android版本 <code>cordova platform update android</code></li><li>卸载当前版本的android <code>cordova platform rm android</code></li><li>安装指定版本的android <code>cordova platform add android@6.2.1</code></li></ol><h2 id="cordova事件"><a href="#cordova事件" class="headerlink" title="cordova事件"></a>cordova事件</h2><ol><li>deviceready(设备就绪)</li><li>pause（应用挂起，切换到后台）</li><li>resume（应用回来，切换到前台）</li><li>backbutton（点击回退按钮 ）</li><li>menubutton（按下菜单按钮）</li></ol><p>​    ……</p><h2 id="cordova插件"><a href="#cordova插件" class="headerlink" title="cordova插件"></a>cordova插件</h2><ol><li>cordova-plugin-statusbar：用于设置状态栏样式</li></ol><h2 id="集成vue"><a href="#集成vue" class="headerlink" title="集成vue"></a>集成vue</h2><h3 id="资源目录"><a href="#资源目录" class="headerlink" title="资源目录"></a>资源目录</h3><ol><li>vue ==&gt; src（资源目录）===&gt; dist（打包目录）</li><li>cordova ===&gt; www（资源目录） ===&gt;平台目录（打包目录）</li><li>vue集成cordova：src ===&gt; www ===&gt; 平台目录</li></ol><h3 id="分两个项目包"><a href="#分两个项目包" class="headerlink" title="分两个项目包"></a>分两个项目包</h3><ol><li><p>vue的index.html中引入cordova.js</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;cordova.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>修改vue默认打包位置（dist更改为www）</p><ul><li>文件排列方式如下所示：</li></ul><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230720151519106.png" alt="项目目录排列方式"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue.config.js中</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">lintOnSave</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">outputDir</span>: <span class="string">&#x27;../www&#x27;</span>, <span class="comment">//修改打包位置</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p> 在vue的index.html中引入cordova的meta标签</p></li></ol><ul><li>将cordova项目-&gt;index.html中的meta标签，删除一下重复的</li></ul><ol start="4"><li><p>在vue/src/main.js)添加deviceready事件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;deviceready&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li><li><p>运行命令</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br><span class="line">cordova emulate android --verbose</span><br></pre></td></tr></table></figure></li></ol><h3 id="一个项目包"><a href="#一个项目包" class="headerlink" title="一个项目包"></a>一个项目包</h3><ol><li><p>vue的index.html中引入cordova.js(同上)</p></li><li><p>修改vue默认打包名称（dist更改为www）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构不同于上面,这次直接build在本项目中即可</span></span><br><span class="line"><span class="keyword">const</span> &#123; defineConfig &#125; = <span class="built_in">require</span>(<span class="string">&#x27;@vue/cli-service&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">    <span class="attr">transpileDependencies</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">lintOnSave</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">outputDir</span>: <span class="string">&#x27;www&#x27;</span>,</span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p> 在vue的index.html中引入cordova的meta标签(同上)</p></li><li><p>在vue/src/main.js添加deviceready事件(同上)</p></li><li><p>添加cordova的<code>config.xml</code>到vue项目中</p><ul><li>复制过去即可</li></ul></li><li><p>构建出www目录</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li><p>添加平台</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cordova platform add android@6.2.1</span><br></pre></td></tr></table></figure></li><li><p>运行</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cordova run android</span><br></pre></td></tr></table></figure></li></ol><h3 id="集成命令-cordova命令集成到vue中-暂时有点问题，集成失败"><a href="#集成命令-cordova命令集成到vue中-暂时有点问题，集成失败" class="headerlink" title="集成命令(cordova命令集成到vue中)(暂时有点问题，集成失败)"></a>集成命令(cordova命令集成到vue中)(暂时有点问题，集成失败)</h3><ol><li><p>在第三步中，虽然只有一个项目bao，但是我们在使用命令的时候，需要npm和cordova之间进行切换，很麻烦，所以可以运用cordova-lib将cordova命令集成到npm中</p></li><li><p>cordova-lib允许在npm中使用cordova命令 <code>npm i cordova-lib</code></p></li><li><p>集成(vue.plugins.service)</p></li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="cordova-android版本问题"><a href="#cordova-android版本问题" class="headerlink" title="cordova-android版本问题"></a>cordova-android版本问题</h3><ol><li><p>在使用过程中，在运行<code>cordova platform add android</code> 后执行<code>cordova run android</code>会报错如下所示，虽然在提示的这个目录下并没有这个templates目录，但是在安装Android Studio过程中并没有什么差错，所以一时间并不知道从哪查起，但是在网上看到了一种解决方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Could not find gradle wrapper within Android SDK. Might need to update your Android SDK</span><br><span class="line"></span><br><span class="line">Looked here: D:/appDownload/Android/Sdk/tools/templates/gradle/wrapper</span><br></pre></td></tr></table></figure></li></ol><p>​        <a href="https://stackoverflow.com/questions/42668185/could-not-find-gradle-wrapper-within-android-sdk-might-need-to-update-your-andr">原文链接</a></p><blockquote><p>Google 通过最新的 sdk 工具更新破坏了 Cordova Android 6.1.x 和其他一些框架。</p><p>Cordova Android 6.2.1 已发布，现已兼容最新的 Android SDK。</p><p>您可以使用以下命令更新当前不兼容的 Android 平台<code>cordova platform update android@6.2.1</code></p><p>或者您可以删除现有平台并添加新平台（将删除您在 Project/platforms/android/ 文件夹中所做的任何手动更改）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cordova platform rm android </span><br><span class="line">cordova platform add android@6.2.1</span><br></pre></td></tr></table></figure><p>您必须指定版本，因为当前 CLI 默认安装 6.1.x。</p></blockquote><p>最后通过安装6.2版本的cordova android解决了问题。</p><h3 id="cordova集成vue路由问题"><a href="#cordova集成vue路由问题" class="headerlink" title="cordova集成vue路由问题"></a>cordova集成vue路由问题</h3><ol><li>app里没有浏览器，也就没有history对象，所以在使用路由时，需要使用hash路由，不能使用history路由</li></ol><h3 id="移动端热更新"><a href="#移动端热更新" class="headerlink" title="移动端热更新"></a>移动端热更新</h3><ol><li><p>移动端热更新：</p><ol><li><p>通过vue的热更新实现的，可以先启动vue项目，但是对于移动端的一些配置，vue并不能使用，所以对于cordova的一些配置需要加上环境判断。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//index.html中，之前引入的cordovajs和meta标签都需要加上判断</span><br><span class="line"></span><br><span class="line">&lt;% if(process.env.NODE_ENV === &quot;production&quot;) &#123;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag"><span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;self&#x27; data: gap: https://ssl.gstatic.com &#x27;unsafe-eval&#x27;; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; media-src *; img-src &#x27;self&#x27; data: content:;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;format-detection&quot;</span> <span class="attr">content</span>=<span class="string">&quot;telephone=no&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;msapplication-tap-highlight&quot;</span> <span class="attr">content</span>=<span class="string">&quot;no&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;user-scalable=no, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width&quot;</span>/&gt;</span></span><br><span class="line">&lt;% &#125; else&#123; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">......</span><br><span class="line">&lt;% if(process.env.NODE_ENV === &quot;production&quot;) &#123;%&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;cordova.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js中</span></span><br><span class="line"><span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&quot;production&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;deviceready&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line">    &#125;, <span class="literal">false</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>在config.xml中添加content标签，content标签主要指定app开始指向页面，将content指向vuer本地起的服务IP地址，就可以实现移动端热更新</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//默认情况下</span><br><span class="line"><span class="tag">&lt;<span class="name">content</span> <span class="attr">src</span>=<span class="string">&quot;index.html&quot;</span>/&gt;</span></span><br><span class="line">//新增的</span><br><span class="line"><span class="tag">&lt;<span class="name">content</span> <span class="attr">src</span>=<span class="string">&quot;http://10.130.76.32:8080&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>所以移动端的热更新是通过vue实现的，如果本地没有起服务，那么移动端会报错连接不到。</p></li><li><p>但是由于cordova是通过vue’实现的，所以在实现热更新的情况下，cordova事件并不会触发，像 <code>menubutton</code> <code>volumeupbutton</code>等等，只要是cordova的事件，都不会触发，如果想进行事件的验证，只需要将config.xml中的<code>&lt;content src=&quot;http://10.130.76.32:8080&quot; /&gt;</code>注销并打包，重启Android模拟器设备即可。</p></li></ol><h3 id="版本问题报错"><a href="#版本问题报错" class="headerlink" title="版本问题报错"></a>版本问题报错</h3><ol><li><p>npm run build报错如下，直接执行命令<code>npm i vue@3.2.26</code> 即可</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230722132931260.png" alt="报错信息"></p></li><li><p>在执行<code>npm i -g cordova</code> 或者  <code>cordova add platform android</code> 时报错 ，可能是由于node版本太低，当安装指定版本的cordova和cordova-android时就ok了。</p></li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境安装&quot;&gt;&lt;a href=&quot;#环境安装&quot; class=&quot;headerlink&quot; title=&quot;环境安装&quot;&gt;&lt;/a&gt;环境安装&lt;/h2&gt;&lt;h3 id=&quot;Android环境&quot;&gt;&lt;a href=&quot;#Android环境&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="cordova" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/cordova/"/>
    
    <category term="移动端框架" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/cordova/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="移动端框架" scheme="https://blog.wxywxy.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    <category term="cordova" scheme="https://blog.wxywxy.cn/tags/cordova/"/>
    
  </entry>
  
  <entry>
    <title>vue3</title>
    <link href="https://blog.wxywxy.cn/2023/07/18/vue3/"/>
    <id>https://blog.wxywxy.cn/2023/07/18/vue3/</id>
    <published>2023-07-18T03:45:12.000Z</published>
    <updated>2023-07-18T13:29:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3"><a href="#Vue3" class="headerlink" title="Vue3"></a>Vue3</h1><img src="https://user-images.githubusercontent.com/499550/93624428-53932780-f9ae-11ea-8d16-af949e16a09f.png" style="width:200px" /><h2 id="1-Vue3简介"><a href="#1-Vue3简介" class="headerlink" title="1.Vue3简介"></a>1.Vue3简介</h2><ul><li>2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王）</li><li>耗时2年多、<a href="https://github.com/vuejs/vue-next/graphs/commit-activity">2600+次提交</a>、<a href="https://github.com/vuejs/rfcs/tree/master/active-rfcs">30+个RFC</a>、<a href="https://github.com/vuejs/vue-next/pulls?q=is:pr+is:merged+-author:app/dependabot-preview+">600+次PR</a>、<a href="https://github.com/vuejs/vue-next/graphs/contributors">99位贡献者</a> </li><li>github上的tags地址：<a href="https://github.com/vuejs/vue-next/releases/tag/v3.0.0">https://github.com/vuejs/vue-next/releases/tag/v3.0.0</a></li></ul><h2 id="2-Vue3带来了什么"><a href="#2-Vue3带来了什么" class="headerlink" title="2.Vue3带来了什么"></a>2.Vue3带来了什么</h2><h3 id="1-性能的提升"><a href="#1-性能的提升" class="headerlink" title="1.性能的提升"></a>1.性能的提升</h3><ul><li><p>打包大小减少41%</p></li><li><p>初次渲染快55%, 更新渲染快133%</p></li><li><p>内存减少54%</p><p>  ……</p></li></ul><h3 id="2-源码的升级"><a href="#2-源码的升级" class="headerlink" title="2.源码的升级"></a>2.源码的升级</h3><ul><li><p>使用Proxy代替defineProperty实现响应式</p></li><li><p>重写虚拟DOM的实现和Tree-Shaking</p><p>  ……</p></li></ul><h3 id="3-拥抱TypeScript"><a href="#3-拥抱TypeScript" class="headerlink" title="3.拥抱TypeScript"></a>3.拥抱TypeScript</h3><ul><li>Vue3可以更好的支持TypeScript</li></ul><h3 id="4-新的特性"><a href="#4-新的特性" class="headerlink" title="4.新的特性"></a>4.新的特性</h3><ol><li><p>Composition API（组合API）</p><ul><li>setup配置</li><li>ref与reactive</li><li>watch与watchEffect</li><li>provide与inject</li><li>……</li></ul></li><li><p>新的内置组件</p><ul><li>Fragment </li><li>Teleport</li><li>Suspense</li></ul></li><li><p>其他改变</p><ul><li>新的生命周期钩子</li><li>data 选项应始终被声明为一个函数</li><li>移除keyCode支持作为 v-on 的修饰符</li><li>……</li></ul></li></ol><h1 id="一、创建Vue3-0工程"><a href="#一、创建Vue3-0工程" class="headerlink" title="一、创建Vue3.0工程"></a>一、创建Vue3.0工程</h1><h2 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h2><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure><h2 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h2><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p><p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p><ul><li><p>什么是vite？—— 新一代前端构建工具。</p></li><li><p>优势如下：</p><ul><li>开发环境中，无需打包操作，可快速的冷启动。</li><li>轻量快速的热重载（HMR）。</li><li>真正的按需编译，不再等待整个应用编译完成。</li></ul>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure></li></ul><h1 id="二、常用-Composition-API"><a href="#二、常用-Composition-API" class="headerlink" title="二、常用 Composition API"></a>二、常用 Composition API</h1><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p><h2 id="1-拉开序幕的setup"><a href="#1-拉开序幕的setup" class="headerlink" title="1.拉开序幕的setup"></a>1.拉开序幕的setup</h2><ol><li>理解：Vue3.0中一个新的配置项，值为一个函数。</li><li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li><li>组件中所用到的：数据、方法等等，均要配置在setup中。</li><li>setup函数的两种返回值：<ol><li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li><li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li></ol></li><li>注意点：<ol><li>尽量不要与Vue2.x配置混用<ul><li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li><li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li><li>如果有重名, setup优先。</li></ul></li><li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li></ol></li></ol><h2 id="2-ref函数"><a href="#2-ref函数" class="headerlink" title="2.ref函数"></a>2.ref函数</h2><ul><li>作用: 定义一个响应式的数据</li><li>语法: <code>const xxx = ref(initValue)</code> <ul><li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li><li>JS中操作数据： <code>xxx.value</code></li><li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li></ul></li><li>备注：<ul><li>接收的数据可以是：基本类型、也可以是对象类型。</li><li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li><li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li></ul></li></ul><h2 id="3-reactive函数"><a href="#3-reactive函数" class="headerlink" title="3.reactive函数"></a>3.reactive函数</h2><ul><li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li><li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li><li>reactive定义的响应式数据是“深层次的”。</li><li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li></ul><h2 id="4-Vue3-0中的响应式原理"><a href="#4-Vue3-0中的响应式原理" class="headerlink" title="4.Vue3.0中的响应式原理"></a>4.Vue3.0中的响应式原理</h2><h3 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h3><ul><li><p>实现原理：</p><ul><li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p></li><li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹），先正常调用原生的数组方法，再更新页面。</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>存在问题：</p><ul><li>新增属性、删除属性, 界面不会更新。</li><li>直接通过下标修改数组, 界面不会自动更新。</li></ul></li></ul><h3 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h3><ul><li><p>实现原理: </p><ul><li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p></li><li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p></li><li><p>MDN文档中描述的Proxy与Reflect(ES6新增)：</p><ul><li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p></li><li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Proxy</span>(data, &#123;</span><br><span class="line"><span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">deleteProperty</span>(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.<span class="property">name</span> = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="5-reactive对比ref"><a href="#5-reactive对比ref" class="headerlink" title="5.reactive对比ref"></a>5.reactive对比ref</h2><ul><li>从定义数据角度对比：<ul><li> ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li><li> reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li><li> 备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li></ul></li><li>从原理角度对比：<ul><li> ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li><li> reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li></ul></li><li>从使用角度对比：<ul><li> ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li><li> reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li></ul></li></ul><h2 id="6-setup的两个注意点"><a href="#6-setup的两个注意点" class="headerlink" title="6.setup的两个注意点"></a>6.setup的两个注意点</h2><ul><li><p>setup执行的时机</p><ul><li>在beforeCreate之前执行一次，this是undefined。</li></ul></li><li><p>setup的参数</p><ul><li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li><li>context：上下文对象<ul><li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li><li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li><li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li></ul></li></ul></li></ul><h2 id="7-计算属性与监视"><a href="#7-计算属性与监视" class="headerlink" title="7.计算属性与监视"></a>7.计算属性与监视</h2><h3 id="1-computed函数"><a href="#1-computed函数" class="headerlink" title="1.computed函数"></a>1.computed函数</h3><ul><li><p>与Vue2.x中computed配置功能一致</p></li><li><p>写法</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = <span class="title function_">computed</span>(&#123;</span><br><span class="line">        <span class="title function_">get</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> person.<span class="property">firstName</span> + <span class="string">&#x27;-&#x27;</span> + person.<span class="property">lastName</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">set</span>(<span class="params">value</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.<span class="title function_">split</span>(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.<span class="property">firstName</span> = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.<span class="property">lastName</span> = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-watch函数"><a href="#2-watch函数" class="headerlink" title="2.watch函数"></a>2.watch函数</h3><ul><li><p>与Vue2.x中watch配置功能一致</p></li><li><p>两个小“坑”：</p><ul><li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li><li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li></ul>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line"><span class="title function_">watch</span>([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="title function_">watch</span>(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line"><span class="title function_">watch</span>([<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">()=&gt;</span>person.<span class="property">name</span>],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line"><span class="title function_">watch</span>(<span class="function">()=&gt;</span>person.<span class="property">job</span>,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-watchEffect函数"><a href="#3-watchEffect函数" class="headerlink" title="3.watchEffect函数"></a>3.watchEffect函数</h3><ul><li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p></li><li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p></li><li><p>watchEffect有点像computed：</p><ul><li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li><li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li></ul>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line"><span class="title function_">watchEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.<span class="property">value</span></span><br><span class="line">    <span class="keyword">const</span> x2 = person.<span class="property">age</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="8-生命周期"><a href="#8-生命周期" class="headerlink" title="8.生命周期"></a>8.生命周期</h2><ul><li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul><li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li><li><code>destroyed</code>改名为 <code>unmounted</code></li></ul></li><li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul><li><code>beforeCreate</code>===&gt;<code>setup()</code></li><li><code>created</code>=======&gt;<code>setup()</code></li><li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li><li><code>mounted</code>=======&gt;<code>onMounted</code></li><li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li><li><code>updated</code> =======&gt;<code>onUpdated</code></li><li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li><li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li></ul></li></ul><h2 id="9-自定义hook函数"><a href="#9-自定义hook函数" class="headerlink" title="9.自定义hook函数"></a>9.自定义hook函数</h2><ul><li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了<strong style="color:#DD5145">封装</strong>。</p></li><li><p>类似于vue2.x中的mixin。</p></li><li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p></li></ul><h2 id="10-toRef"><a href="#10-toRef" class="headerlink" title="10.toRef"></a>10.toRef</h2><ul><li>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</li><li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li><li>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</li></ul><ul><li>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></li></ul><h1 id="三、其它-Composition-API"><a href="#三、其它-Composition-API" class="headerlink" title="三、其它 Composition API"></a>三、其它 Composition API</h1><h2 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h2><ul><li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p></li><li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p></li><li><p>什么时候使用?</p><ul><li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li><li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li></ul></li></ul><h2 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h2><ul><li>readonly: 让一个响应式数据变为只读的（深只读）。</li><li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li><li>应用场景: 不希望数据被修改时。</li></ul><h2 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h2><ul><li>toRaw：<ul><li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li><li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li></ul></li><li>markRaw：<ul><li>作用：标记一个对象，使其永远不会再成为响应式对象。</li><li>应用场景:<ol><li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li><li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li></ol></li></ul></li></ul><h2 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h2><ul><li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p></li><li><p>实现防抖效果：</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">name:&#x27;Demo&#x27;,</span><br><span class="line">setup()&#123;</span><br><span class="line">// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">//自定义一个myRef</span><br><span class="line">function myRef(value,delay)&#123;</span><br><span class="line">let timer</span><br><span class="line">//通过customRef去实现自定义</span><br><span class="line">return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">return&#123;</span><br><span class="line">get()&#123;</span><br><span class="line">track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">return value</span><br><span class="line">&#125;,</span><br><span class="line">set(newValue)&#123;</span><br><span class="line">clearTimeout(timer)</span><br><span class="line">timer = setTimeout(()=&gt;&#123;</span><br><span class="line">value = newValue</span><br><span class="line">trigger() //告诉Vue去更新界面</span><br><span class="line">&#125;,delay)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line">let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">return &#123;</span><br><span class="line">keyword</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h2><ul><li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p></li><li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p></li><li><p>具体写法：</p><ol><li><p>祖组件中：</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params"></span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">let</span> car = <span class="title function_">reactive</span>(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    <span class="title function_">provide</span>(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>后代组件中：</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setup</span>(<span class="params">props,context</span>)&#123;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">const</span> car = <span class="title function_">inject</span>(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h2 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h2><ul><li>isRef: 检查一个值是否为一个 ref 对象</li><li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li><li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li><li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li></ul><h1 id="四、Composition-API-的优势"><a href="#四、Composition-API-的优势" class="headerlink" title="四、Composition API 的优势"></a>四、Composition API 的优势</h1><h2 id="1-Options-API-存在的问题"><a href="#1-Options-API-存在的问题" class="headerlink" title="1.Options API 存在的问题"></a>1.Options API 存在的问题</h2><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p><div style="width:600px;height:370px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" style="width:600px;float:left" /></div><div style="width:300px;height:370px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" style="zoom:50%;width:560px;left" /> </div><h2 id="2-Composition-API-的优势"><a href="#2-Composition-API-的优势" class="headerlink" title="2.Composition API 的优势"></a>2.Composition API 的优势</h2><p>我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。</p><div style="width:500px;height:340px;overflow:hidden;float:left">    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc0be8211fc54b6c941c036791ba4efe~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><div style="width:430px;height:340px;overflow:hidden;float:left">    <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cc55165c0e34069a75fe36f8712eb80~tplv-k3u1fbpfcp-watermark.image"style="height:360px"/></div><h1 id="五、新的组件"><a href="#五、新的组件" class="headerlink" title="五、新的组件"></a>五、新的组件</h1><h2 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h2><ul><li>在Vue2中: 组件必须有一个根标签</li><li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li><li>好处: 减少标签层级, 减小内存占用</li></ul><h2 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h2><ul><li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h2><ul><li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p></li><li><p>使用步骤：</p><ul><li><p>异步引入组件</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Child</span> = <span class="title function_">defineAsyncComponent</span>(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br></pre></td></tr></table></figure></li><li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">&lt;Suspense&gt;</span><br><span class="line">&lt;template v-slot:default&gt;</span><br><span class="line">&lt;Child/&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-slot:fallback&gt;</span><br><span class="line">&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;/Suspense&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h1><h2 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h2><ul><li><p>Vue 2.x 有许多全局 API 和配置。</p><ul><li><p>例如：注册全局组件、注册全局指令等。</p>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">component</span>(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.<span class="title function_">focus</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Vue3.0中对这些API做出了调整：</p><ul><li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p><table><thead><tr><th>2.x 全局 API（<code>Vue</code>）</th><th>3.x 实例 API (<code>app</code>)</th></tr></thead><tbody><tr><td>Vue.config.xxxx</td><td>app.config.xxxx</td></tr><tr><td>Vue.config.productionTip</td><td><strong style="color:#DD5145">移除</strong></td></tr><tr><td>Vue.component</td><td>app.component</td></tr><tr><td>Vue.directive</td><td>app.directive</td></tr><tr><td>Vue.mixin</td><td>app.mixin</td></tr><tr><td>Vue.use</td><td>app.use</td></tr><tr><td>Vue.prototype</td><td>app.config.globalProperties</td></tr></tbody></table></li></ul></li></ul><h2 id="2-插槽"><a href="#2-插槽" class="headerlink" title="2.插槽"></a>2.插槽</h2><ul><li><p><strong style="color:#DD5145">具名</strong>插槽和<strong style="color:#DD5145">作用域</strong>插槽</p><ul><li><p>匿名插槽是没有变化的</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父组件中:</span><br><span class="line">&lt;child&gt;</span><br><span class="line">&lt;span&gt;匿名插槽&lt;span&gt;</span><br><span class="line">&lt;child&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot&gt;&lt;/slot&gt;    </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong style="color:#DD5145">具名</strong>插槽</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue2</span><br><span class="line">父组件中:</span><br><span class="line">&lt;child&gt;</span><br><span class="line">&lt;span slot=&quot;test&quot;&gt;具名插槽&lt;span&gt;</span><br><span class="line">&lt;child&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot name=&quot;test&quot;&gt;&lt;/slot&gt;    </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue3</span><br><span class="line">父组件中:</span><br><span class="line">&lt;child&gt;</span><br><span class="line">    &lt;template v-slot:test&gt;</span><br><span class="line">&lt;span slot=&quot;test&quot;&gt;具名插槽&lt;span&gt;</span><br><span class="line">    &lt;/template&gt;</span><br><span class="line">&lt;child&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot name=&quot;test&quot;&gt;&lt;/slot&gt;    </span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong style="color:#DD5145">作用域</strong>插槽</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue2</span><br><span class="line">父组件中:</span><br><span class="line">&lt;child&gt;</span><br><span class="line">&lt;span slot-scoped=&quot;number&quot;&gt;作用域插槽&#123;&#123;number&#125;&#125;&lt;span&gt;</span><br><span class="line">&lt;child&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot :number=&quot;num&quot;&gt;&lt;/slot&gt;    </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">...</span><br><span class="line">data() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">num:1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue3</span><br><span class="line">父组件中:</span><br><span class="line">&lt;child&gt;</span><br><span class="line">&lt;template #default=&quot;&#123;number&#125;&quot;&gt;</span><br><span class="line">&lt;span&gt;作用域插槽&#123;&#123;number.num&#125;&#125;&lt;span&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;child&gt;</span><br><span class="line">子组件中：</span><br><span class="line">&lt;div&gt;</span><br><span class="line">&lt;slot :number=&quot;number&quot;&gt;&lt;/slot&gt;    </span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">...</span><br><span class="line">setup()&#123;</span><br><span class="line">let number = reactive(&#123; num: 1 &#125;)</span><br><span class="line">return &#123;</span><br><span class="line">number</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="3-其他改变"><a href="#3-其他改变" class="headerlink" title="3.其他改变"></a>3.其他改变</h2><ul><li><p>data选项应始终被声明为一个函数。</p></li><li><p>过度类名的更改：</p><ul><li><p>Vue2.x写法</p>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Vue3.x写法</p>  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p></li><li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p><ul><li><p>父组件中绑定事件</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></li><li><p>子组件中声明自定义事件</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p><blockquote><p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p></blockquote></li><li><p><strong style="color:#DD5145">props</strong>声明位置</p><ul><li><p>Vue2</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">props:[......]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>Vue3，对props进行接收配置，否则在setup中访问props就是undefined</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">        props:&#123;//接收配置</span><br><span class="line">            ....</span><br><span class="line">        &#125;</span><br><span class="line">setup(props) &#123;</span><br><span class="line">            //进行访问props中的属性</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong style="color:#DD5145">emit</strong>自定义事件触发</p><ul><li><p>Vue2</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">......</span><br><span class="line">this.$emit()</span><br><span class="line">......</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>Vue3</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">......</span><br><span class="line">setup(props , context) &#123;</span><br><span class="line">    ...</span><br><span class="line">        context.emit()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3&quot;&gt;&lt;a href=&quot;#Vue3&quot; class=&quot;headerlink&quot; title=&quot;Vue3&quot;&gt;&lt;/a&gt;Vue3&lt;/h1&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/499550/936244</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue3" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/vue3/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="vue3" scheme="https://blog.wxywxy.cn/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>小知识总结(持续更新)</title>
    <link href="https://blog.wxywxy.cn/2023/07/18/%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.wxywxy.cn/2023/07/18/%E5%B0%8F%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</id>
    <published>2023-07-18T03:45:12.000Z</published>
    <updated>2023-08-11T11:48:03.936Z</updated>
    
    <content type="html"><![CDATA[<h2 id="判断当前设备是否为移动设备"><a href="#判断当前设备是否为移动设备" class="headerlink" title="判断当前设备是否为移动设备"></a>判断当前设备是否为移动设备</h2><ol><li><p>如下所示，如果是，则isMobile为true，否则为false</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法一:</span></span><br><span class="line"><span class="keyword">const</span> isMobile = <span class="regexp">/Mobi|Android|iPhone/i</span>.<span class="title function_">test</span>(navigator.<span class="property">userAgent</span>)</span><br><span class="line"><span class="comment">//写法二:</span></span><br><span class="line"><span class="keyword">const</span> isMobile = navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/Mobi/i</span>) || navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/Android/i</span>)||navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/iPhone/i</span>) </span><br></pre></td></tr></table></figure></li></ol><h2 id="vite项目中判断开发环境和生产环境"><a href="#vite项目中判断开发环境和生产环境" class="headerlink" title="vite项目中判断开发环境和生产环境"></a>vite项目中判断开发环境和生产环境</h2><ol><li><p>项目根目录新建 <code>.env.production</code> 和 <code>.env.development</code></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#.env.production文件</span><br><span class="line"></span><br><span class="line">VITE_NAME = production</span><br><span class="line">#线上地址</span><br><span class="line">VITE_API_BASE_URL = &#x27;&#x27;</span><br><span class="line">#端口</span><br><span class="line">VITE_PORT = &#x27;&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#.env.development文件</span><br><span class="line"></span><br><span class="line">VITE_NAME = production</span><br><span class="line">#开发地址</span><br><span class="line">VITE_API_BASE_URL = &#x27;&#x27;</span><br><span class="line">#端口</span><br><span class="line">VITE_PORT = &#x27;&#x27;</span><br></pre></td></tr></table></figure></li><li><p>vite.config.js中配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig, loadEnv &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="keyword">import</span> vue <span class="keyword">from</span> <span class="string">&#x27;@vitejs/plugin-vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; resolve &#125; <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Components</span> <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/vite&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">VantResolver</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;unplugin-vue-components/resolvers&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; command, mode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> env = <span class="title function_">loadEnv</span>(mode, process.<span class="title function_">cwd</span>(), <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="comment">// 服务器配置</span></span><br><span class="line">    <span class="attr">server</span>: &#123;</span><br><span class="line">      <span class="attr">host</span>: <span class="string">&#x27;0.0.0.0&#x27;</span>,</span><br><span class="line">      <span class="attr">port</span>: env.<span class="property">VITE_PORT</span>,</span><br><span class="line">      <span class="comment">// 是否开启 https</span></span><br><span class="line">      <span class="attr">https</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">define</span>: &#123; <span class="string">&#x27;process.env&#x27;</span>: env &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在 <code>package.json</code> 中配置</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite --mode development&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite build --mode production&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite preview&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure></li><li><p>接下来就可以全局使用process.env进行环境的判断了</p></li></ol><h2 id="vite-vue项目的移动端适配"><a href="#vite-vue项目的移动端适配" class="headerlink" title="vite+vue项目的移动端适配"></a>vite+vue项目的移动端适配</h2><ol><li><p>安装插件</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i amfe-flexible</span><br><span class="line">npm i autoprefixer</span><br><span class="line">npm i postcss-pxtorem</span><br></pre></td></tr></table></figure></li><li><p>vite.config.js配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> autoprefixer <span class="keyword">from</span> <span class="string">&#x27;autoprefixer&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> postCssPxToRem <span class="keyword">from</span> <span class="string">&#x27;postcss-pxtorem&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; command, mode &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">css</span>: &#123;</span><br><span class="line">      <span class="attr">postcss</span>: &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [</span><br><span class="line">          <span class="title function_">autoprefixer</span>(&#123;</span><br><span class="line">            <span class="attr">overrideBrowserslist</span>: [<span class="string">&#x27;Android 4.1&#x27;</span>, <span class="string">&#x27;iOS 7.1&#x27;</span>, <span class="string">&#x27;Chrome &gt; 31&#x27;</span>, <span class="string">&#x27;ff &gt; 31&#x27;</span>, <span class="string">&#x27;ie &gt;= 8&#x27;</span>],</span><br><span class="line">          &#125;),</span><br><span class="line">          <span class="title function_">postCssPxToRem</span>(&#123;</span><br><span class="line">            <span class="comment">// 自适应，px&gt;rem转换</span></span><br><span class="line">            <span class="attr">rootValue</span>: <span class="number">37.5</span>, <span class="comment">// 75表示750设计稿，37.5表示375设计稿</span></span><br><span class="line">            <span class="attr">propList</span>: [<span class="string">&#x27;*&#x27;</span>], <span class="comment">// 需要转换的属性，这里选择全部都进行转换</span></span><br><span class="line">            <span class="attr">selectorBlackList</span>: [<span class="string">&#x27;norem&#x27;</span>], <span class="comment">// 过滤掉norem-开头的class，不进行rem转换</span></span><br><span class="line">          &#125;),</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>ok，成功配置，之后根据设计稿的UI，是多少呢px就写多少px，之后会自动转换成rem适配移动端，如果有些单位不想被转换，则将px写为大写即可</p></li></ol><h2 id="vue3中reactive变量失效问题"><a href="#vue3中reactive变量失效问题" class="headerlink" title="vue3中reactive变量失效问题"></a>vue3中reactive变量失效问题</h2><ol><li><p>在vue3中响应式数据通过ref或者reactive进行定义，但是对于reactive定义的数据，对其进行赋值时会丢失响应式，目前还未去了解原因，但是丢失响应式是真实存在的</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> infoList = <span class="title function_">reactive</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">testFunction</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> .....异步请求</span><br><span class="line">    infoList = result.<span class="property">data</span> <span class="comment">//此时infoList就不是响应式数据了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决方法</p><ol><li><p>第一种：使用ref</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> infoList = <span class="title function_">ref</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">testFunction</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> .....异步请求</span><br><span class="line">    infoList.<span class="property">value</span> = result.<span class="property">data</span> <span class="comment">//此时infoList还是想响应式数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二种：使用嵌套</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> infoList = <span class="title function_">reactive</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">testFunction</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> .....异步请求</span><br><span class="line">    infoList.<span class="property">data</span> = result.<span class="property">data</span> <span class="comment">//此时infoList还是想响应式数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="vue3移动端开发页面跳转动画"><a href="#vue3移动端开发页面跳转动画" class="headerlink" title="vue3移动端开发页面跳转动画"></a>vue3移动端开发页面跳转动画</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;判断当前设备是否为移动设备&quot;&gt;&lt;a href=&quot;#判断当前设备是否为移动设备&quot; class=&quot;headerlink&quot; title=&quot;判断当前设备是否为移动设备&quot;&gt;&lt;/a&gt;判断当前设备是否为移动设备&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;如下所示，如果是，则isMobil</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="开发知识" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="开发知识" scheme="https://blog.wxywxy.cn/tags/%E5%BC%80%E5%8F%91%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>关于node-sass安装问题</title>
    <link href="https://blog.wxywxy.cn/2023/07/10/%E5%85%B3%E4%BA%8Enode-sass%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.wxywxy.cn/2023/07/10/%E5%85%B3%E4%BA%8Enode-sass%E5%AE%89%E8%A3%85%E9%97%AE%E9%A2%98/</id>
    <published>2023-07-10T03:45:12.000Z</published>
    <updated>2023-07-18T13:26:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于node-sass安装问题"><a href="#关于node-sass安装问题" class="headerlink" title="关于node-sass安装问题"></a>关于node-sass安装问题</h3><h4 id="node与node-sass版本对应问题"><a href="#node与node-sass版本对应问题" class="headerlink" title="node与node-sass版本对应问题"></a>node与node-sass版本对应问题</h4><ol><li><p>这个可以从网上找到对应图，这里列举两个常用的node版本对应的node-sass版本，虽然这里写的node12版本可以安装node-sass4.12+的版本，但是我安装4.9.0版本会报错，报错如下图所示，安装4.12版本成功了。</p><p> <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230710103755403.png" alt="版本不对应报错图"></p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node <span class="number">12</span>  ===&gt;   node-sass  <span class="number">4.12</span>+</span><br><span class="line">node <span class="number">13</span>  ===&gt;   node-sass  <span class="number">4.13</span>+ <span class="language-xml">&lt;5.0</span></span><br><span class="line"><span class="language-xml">node 14  ===&gt;   node-sass  4.14+</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="python环境安装问题"><a href="#python环境安装问题" class="headerlink" title="python环境安装问题"></a>python环境安装问题</h4><ol><li>直接在官网下载python27版本：<a href="https://www.python.org/downloads/release/python-270/">python27</a></li><li>直接默认安装到C:\Python27下</li><li>配置环境变量，在path目录下新增C:\Python27的值</li></ol><h4 id="在终端中查看python版本打开应用商店的问题"><a href="#在终端中查看python版本打开应用商店的问题" class="headerlink" title="在终端中查看python版本打开应用商店的问题"></a>在终端中查看python版本打开应用商店的问题</h4><ol><li><p>在path变量中，将C:\Python27移到最上面</p><p> <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/channelsoft/image-20230710103416332.png" alt="环境变量图"></p></li></ol><h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ol><li><p>还有其他问题可以执行下面这条命令，这条命令可以自动下载和安装所有必须的工具包括 Python、Visual C++ Build Tools 和其他必要的库和工具。</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --<span class="variable language_">global</span> --production windows-build-tools</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;关于node-sass安装问题&quot;&gt;&lt;a href=&quot;#关于node-sass安装问题&quot; class=&quot;headerlink&quot; title=&quot;关于node-sass安装问题&quot;&gt;&lt;/a&gt;关于node-sass安装问题&lt;/h3&gt;&lt;h4 id=&quot;node与node-sas</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="node-sass安装" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/node-sass%E5%AE%89%E8%A3%85/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="node-sass" scheme="https://blog.wxywxy.cn/tags/node-sass/"/>
    
  </entry>
  
  <entry>
    <title>简单的移动端适配</title>
    <link href="https://blog.wxywxy.cn/2023/07/07/%E7%AE%80%E5%8D%95%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    <id>https://blog.wxywxy.cn/2023/07/07/%E7%AE%80%E5%8D%95%E7%9A%84%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/</id>
    <published>2023-07-07T03:45:12.000Z</published>
    <updated>2023-07-18T13:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="移动端简单适配"><a href="#移动端简单适配" class="headerlink" title="移动端简单适配"></a>移动端简单适配</h3><ol><li><p>首先针对菜单栏进行适配，在移动端的时候，菜单栏需要收缩起来，此时需要针对其collapse属性进行监听，当页面宽度小于指定值时，将其折叠，具体实现代码如下所示：</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义data</span></span><br><span class="line"><span class="title function_">data</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">screenWidth</span>: <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span>    </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在mounted中获取屏幕宽度</span></span><br><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="variable language_">this</span></span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">onresize</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 定义窗口大小变更通知事件</span></span><br><span class="line">      _this.<span class="property">screenWidth</span> = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">clientWidth</span> <span class="comment">//窗口宽度</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">//监听屏幕变化</span></span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="attr">screenWidth</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">      <span class="comment">// 屏幕宽度小于500,折叠</span></span><br><span class="line">      <span class="keyword">if</span> (val &lt; <span class="number">500</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isCollapse</span> = <span class="literal">true</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">width</span> = <span class="string">&#x27;64px&#x27;</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// console.log(&#x27;展开&#x27;)</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">isCollapse</span> = <span class="literal">false</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">width</span> = <span class="string">&#x27;200px&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>对于其他组件的适配，使用@media来实现</p> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 屏幕宽度小于500,进行缩放,使用zoom，从左上角进行缩放，使用scale，从中心开始缩放 */</span></span><br><span class="line">@media screen and (max-<span class="attr">width</span>: 500px)&#123;</span><br><span class="line">    .<span class="property">container</span> &#123;</span><br><span class="line">        <span class="attr">zoom</span>:<span class="number">0.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>移动端组件库[Vant](</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;移动端简单适配&quot;&gt;&lt;a href=&quot;#移动端简单适配&quot; class=&quot;headerlink&quot; title=&quot;移动端简单适配&quot;&gt;&lt;/a&gt;移动端简单适配&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;首先针对菜单栏进行适配，在移动端的时候，菜单栏需要收缩起来，此时需要针对其coll</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="移动端适配" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="移动端" scheme="https://blog.wxywxy.cn/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Parcel与Webpack</title>
    <link href="https://blog.wxywxy.cn/2023/06/21/Parcel%E4%B8%8EWebpack/"/>
    <id>https://blog.wxywxy.cn/2023/06/21/Parcel%E4%B8%8EWebpack/</id>
    <published>2023-06-21T10:24:46.000Z</published>
    <updated>2023-08-05T01:26:36.909Z</updated>
    
    <content type="html"><![CDATA[<h3 id="略谈Webpack与Parcel区别"><a href="#略谈Webpack与Parcel区别" class="headerlink" title="略谈Webpack与Parcel区别"></a>略谈Webpack与Parcel区别</h3><p>​    这几天在学ThreeJS，有的博主使用的打包工具为parcel，由于之前没接触过parcel，所以在学习的时候我使用的是webpack，在看完博主的打包过程后，结合自己的打包过程，发现parcel还是非常简便的：</p><ol><li>简单情况下，parcel并不用配置文件，直接在命令里写入口文件和输出文件。相比于webpack在webpack.config.js中书写出入口文件要方便许多。</li></ol><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230621183506560.png" alt="image-20230621183506560"></p><ol start="2"><li>除此之外，parcel并不需要专门的去配置处理html、css等资源，相比于webpack繁琐的配置过程，有较大优势。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;略谈Webpack与Parcel区别&quot;&gt;&lt;a href=&quot;#略谈Webpack与Parcel区别&quot; class=&quot;headerlink&quot; title=&quot;略谈Webpack与Parcel区别&quot;&gt;&lt;/a&gt;略谈Webpack与Parcel区别&lt;/h3&gt;&lt;p&gt;​    这</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="parcel" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/parcel/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="打包工具" scheme="https://blog.wxywxy.cn/tags/%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    
    <category term="parcel" scheme="https://blog.wxywxy.cn/tags/parcel/"/>
    
    <category term="Webpack" scheme="https://blog.wxywxy.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>兼容性问题记录</title>
    <link href="https://blog.wxywxy.cn/2022/11/10/%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>https://blog.wxywxy.cn/2022/11/10/%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</id>
    <published>2022-11-10T07:06:09.000Z</published>
    <updated>2023-06-21T10:28:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="replace和replaceAll"><a href="#replace和replaceAll" class="headerlink" title="replace和replaceAll"></a>replace和replaceAll</h3><ol><li>问题描述：测试人员和开发人员点击复制手机号正常，老师使用点击复制后没反应，Popover没弹出。</li><li>问题定位：通过观察DOM结构，发现Popover先渲染后销毁，然后通过销毁API查找，发现了try，catch中的catch中只执行了一行销毁代码，也不抛出错误，将catch中的代码更改之后，控制台抛出“replaceAll is not defined”，在代码中使用replaceAll将’-‘替换成空字符串</li><li>问题解决：85以下的谷歌浏览器不支持replaceAll，所以要不就是使用replace，要不就是升级浏览器</li></ol><h3 id="Echarts不展示"><a href="#Echarts不展示" class="headerlink" title="Echarts不展示"></a>Echarts不展示</h3><ol><li>问题描述：主页的Echarts图不展示</li><li>问题定位：控制台报错<code>：Cant read properties of undefined(reading init)</code></li><li>问题排查：init报错-&gt;Echarts初始化API失败，引用方式：<code>import echarts from &#39;echarts&#39;</code>，echarts对象获取不到，导致init失败，判断是否为echarts版本问题。线上引用版本为5.1.2，私包使用版本为4.7.0，两者导出规范不同，5.1.2导入方式为<code>import * as echarts from &#39;echarts&#39;</code>，如果之后的echarts版本不使用该引入方式，则图表不会显示。</li></ol><h3 id="页面频闪问题"><a href="#页面频闪问题" class="headerlink" title="页面频闪问题"></a>页面频闪问题</h3><ol><li>问题描述：使用el-table表格组件页面一直抖动，横向纵向进度条不停消失，展示导致的。</li><li>问题定位：通过观察抖动过程中的宽度属性，发现el-table的宽度在不断变化，而该宽度属性是el-table组件内部的计算的结果属性，因此问题可能与计算机制有关</li><li>问题解决：github上有类似问题，但并没有解决方法，是elementui遗留问题，可以通过改变缩放比例来规避</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;replace和replaceAll&quot;&gt;&lt;a href=&quot;#replace和replaceAll&quot; class=&quot;headerlink&quot; title=&quot;replace和replaceAll&quot;&gt;&lt;/a&gt;replace和replaceAll&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="webpack" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/webpack/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="webpack" scheme="https://blog.wxywxy.cn/tags/webpack/"/>
    
    <category term="性能优化" scheme="https://blog.wxywxy.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>webpack的externals</title>
    <link href="https://blog.wxywxy.cn/2022/11/10/webpack%E7%9A%84externals/"/>
    <id>https://blog.wxywxy.cn/2022/11/10/webpack%E7%9A%84externals/</id>
    <published>2022-11-10T06:56:41.000Z</published>
    <updated>2022-11-10T08:32:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="webpack中的externals"><a href="#webpack中的externals" class="headerlink" title="webpack中的externals"></a>webpack中的externals</h4><ol><li><p>目标：解决前端项目打包后文件过大的问题。</p></li><li><p>如何实现：在Vue中通过Vue.config.js中进行配置，配置完成后，webpack在打包时不会打包配置的库，可以极大的减少打包后文件的大小。</p></li><li><p>随便使用了个项目，使用方式一：</p><ul><li><p>先在index.html中引入不想被打包的库</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/blog/202211101631483.png" alt="image-20221110154505746"></p></li><li><p>在vue.config.js中进行配置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line"><span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;线上问题排查&#x27;</span>,</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">      <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">      <span class="attr">axios</span>: <span class="string">&#x27;axios&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;element-ui&#x27;</span>: <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>效果：如下图所示，可以看到是有明显的体积缩小的，这里只配置了三个库。</p><p>未使用前：</p></li></ol><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/blog/202211101631527.png" alt="image-20221110151941421"></p><p>​    使用后：</p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/blog/202211101631828.png" alt="image-20221110154216542"></p><ol start="5"><li>使用方式二：</li></ol><ul><li><p>在index.html中引入</p></li><li><p>下载html-webpack-externals-plugin</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i html-webpack-externals-plugin -D</span><br></pre></td></tr></table></figure></li><li><p>vue.config.js中使用</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">HtmlWebpackExternalsPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-externals-plugin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;线上问题排查&#x27;</span>,</span><br><span class="line">    <span class="attr">plugins</span>: [</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">HtmlWebpackExternalsPlugin</span>(&#123;</span><br><span class="line">        <span class="attr">externals</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">module</span>: <span class="string">&#x27;vue&#x27;</span>,</span><br><span class="line">            <span class="attr">entry</span>: <span class="string">&#x27;https://lib.baomitu.com/vue/2.6.12/vue.min.js&#x27;</span>,</span><br><span class="line">            <span class="attr">global</span>: <span class="string">&#x27;Vue&#x27;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">module</span>: <span class="string">&#x27;axios&#x27;</span>,</span><br><span class="line">            <span class="attr">entry</span>: <span class="string">&#x27;https://cdn.bootcdn.net/ajax/libs/axios/1.1.3/axios.min.js&#x27;</span>,</span><br><span class="line">            <span class="attr">global</span>: <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">module</span>: <span class="string">&#x27;element-ui&#x27;</span>,</span><br><span class="line">            <span class="attr">entry</span>: <span class="string">&#x27;https://cdn.bootcdn.net/ajax/libs/element-ui/2.15.10/index.min.js&#x27;</span>,</span><br><span class="line">            <span class="attr">global</span>: <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">module</span>: <span class="string">&#x27;nprogress&#x27;</span>,</span><br><span class="line">            <span class="attr">entry</span>: <span class="string">&#x27;https://cdn.bootcdn.net/ajax/libs/nprogress/0.2.0/nprogress.min.js&#x27;</span>,</span><br><span class="line">            <span class="attr">global</span>: <span class="string">&#x27;nprogress&#x27;</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></li><li><p>这次配置了四个库，所以体积相比于之前又有所减小</p></li></ul><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/blog/202211101631286.png" alt="image20221110163051388"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;webpack中的externals&quot;&gt;&lt;a href=&quot;#webpack中的externals&quot; class=&quot;headerlink&quot; title=&quot;webpack中的externals&quot;&gt;&lt;/a&gt;webpack中的externals&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="webpack" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/webpack/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="webpack" scheme="https://blog.wxywxy.cn/tags/webpack/"/>
    
    <category term="性能优化" scheme="https://blog.wxywxy.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>何为CDN</title>
    <link href="https://blog.wxywxy.cn/2022/11/07/%E4%BD%95%E4%B8%BACDN/"/>
    <id>https://blog.wxywxy.cn/2022/11/07/%E4%BD%95%E4%B8%BACDN/</id>
    <published>2022-11-07T02:21:04.000Z</published>
    <updated>2022-11-07T03:55:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ol><li><p>最近在了解前端性能优化这方面的问题，之前一直听过CDN可以优化性能，但是对其原理还是一知半解，但是最近的一篇文章，让我对其原理有了较为深入的了解，</p></li><li><p>以下为我自己的总结</p><ol><li><p>CDN是为了优化性能而存在的，怎么优化性能呢？</p><ul><li><p>将静态资源部署到CDN上</p></li><li><p>用户访问时离用户最近的CDN进行资源的派发，从而就可以提高速度。</p></li></ul></li></ol><p>​     但是此时会有个问题，怎么判断哪个离用户近呢？</p><ol start="2"><li><p>在了解怎么判断哪个离用户近之前，先了解一下其他信息</p><ul><li>DNS域名解析器，就是通过你输入的域名来解析对应的IP地址，比如你访问 abc.baidu.com,域名解析器会将其解析成10.1.1.1这种类型的IP地址，然后进行访问。但是有的域名还会有别名(CNAME)，例如abc.baidu.com有个别名123.baidu.com,当你访问123.baidu.com，DNS将其解析成adc.baidu.com,然后再解析成IP地址10.1.1.1。也就是说DNS会将域名解析成另外一个域名或者将其解析成一个IP地址。</li><li>现在有许多CDN供应商，阿里，腾讯，只要自己的系统接入了CDN服务，将自己的静态资源上传到CDN服务，那么静态资源就会自动分发到世界各地去。</li></ul></li><li><p>了解上面的知识后，现在来说怎么判断哪个资源IP离用户近</p><ul><li><p>用户访问静态资源通过域名进行访问，DNS需要找离用户最近的IP供用户访问。普通DNS做不到，所以需要一个特殊的DNS，这个DNS需要实现两个功能</p><ol><li>我们需要知道用户的位置，</li><li>其访问域名对应哪些IP，以及这些IP分别在哪，</li></ol><p>针对第一个问题，在用户请求中可以提取到，第二个问题，CDN供应商肯定知道其部署机器的位置以及他们的IP。所以这个问题只能CDN供应商来解决，CDN供应商提供了这个特殊的DNS服务器-CDN专用DNS服务器。</p></li></ul></li><li><p>实现：</p><ul><li>当用户访问123.baidu.com时，它对应一个别名cdn.ali.com，普通的DNS将123.baidu.com解析成cdn.ali.com，该域名对应的也是DNS服务器，所以会将解析任务交给这个CDN专用DNS服务器。特殊的DNS解析器对cdn.ali.com进行解析，根据服务器上所有服务器地址信息。选择离用户最近的服务器地址返回给用户即可。</li></ul></li></ol></li></ol><p><a href="https://www.elecfans.com/d/1161126.html">附上讲解很清晰的一篇文章</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CDN&quot;&gt;&lt;a href=&quot;#CDN&quot; class=&quot;headerlink&quot; title=&quot;CDN&quot;&gt;&lt;/a&gt;CDN&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;最近在了解前端性能优化这方面的问题，之前一直听过CDN可以优化性能，但是对其原理还是一知半解，但是最近的一篇文章，</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="性能优化" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="CDN" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/CDN/"/>
    
    
    <category term="性能优化" scheme="https://blog.wxywxy.cn/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="CDN" scheme="https://blog.wxywxy.cn/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>java学习基础</title>
    <link href="https://blog.wxywxy.cn/2022/11/03/java/"/>
    <id>https://blog.wxywxy.cn/2022/11/03/java/</id>
    <published>2022-11-03T03:45:12.000Z</published>
    <updated>2023-07-31T10:01:52.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ol><li>java跨平台的原因是因为java是运行在虚拟机上的，针对不同的设备安装不同的虚拟机即可</li><li>JVM：java虚拟机，真正运行java程序的地方</li><li>核心类库：java封装好的一些类</li><li>开发工具：包括javac（编译工具），java（运行工具），jdb（调试工具），jhat（内存分析工具）等等</li><li>JDK：java开发工具包，由JVM+核心类库+开发工具组成</li><li>JRE：java运行环境。由JVM+核心类库+运行工具。当别人把编译后的文件发送给其他人进行运行时，只需要安装JRE即可。</li></ol><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li>字面量类型：整数，小数，字符串（双引号引起来），布尔，字符类型（单引号括起来，内容只能有一个，例如’A’）和空类型</li><li>‘\t’制表符：根据前面字符串的长度，如果不够8位，补齐到8位</li><li>基本数据类型：<ul><li>整数： ，short，int，long（变量值后面加L，大小写都可以）</li><li>浮点数：float（变量值后面加F，大小写都可以），short</li><li>字符：chart</li></ul></li></ol><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ol><li><p>项目结构：项目-&gt;module-&gt;包-&gt;类</p></li><li><p>类型转换</p><ul><li><p>隐式转换（自动类型提升）：小范围的类型自动提升为大范围的类型：byte &lt; short &lt; int &lt; long &lt; float &lt; double.  </p></li><li><p>强制类型转换：</p><ul><li><p>格式：目标数据类型 变量名 = （目标数据类型）被强转的数据</p></li><li><p>例如</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">double a = 12.3;</span><br><span class="line">int b = (int)a; </span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>判断是否相等：==    判断是否不等：!=      and运算符：&amp;    or运算符：| 短路and运算符：&amp;&amp;  短路or运算符：||</p></li><li><p>键盘输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Scanner sc = new Scanner(System.in);</span><br><span class="line">System.out.println(&#x27;请输入值&#x27;);</span><br><span class="line">int data = sc.nextInt()</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li><p>生成0-99的随机数：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Random r = new Random()</span><br><span class="line">int number = r.nextInt(100)</span><br></pre></td></tr></table></figure></li><li><p>for(;;):代表无限循环</p></li><li><p>while(true):代表无限循环</p></li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>定义：int [] array 或者 int array[]</p></li><li><p>静态初始化：int [] array = new int[]{1,2,3} 或者简写 int [] array = {1,2,3}</p></li><li><p>动态初始化：int [] array = new int[50]，默认数据都是0</p></li><li><p>栈：存储方法   堆：只要new出来的就存储在堆中 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int[] arr = new int[2]</span><br><span class="line">&#125;</span><br><span class="line">main方法进栈</span><br><span class="line">int[] arr进入栈中的main方法中</span><br><span class="line">等号右边为new关键字，new出来的数组存储在堆中</span><br><span class="line">int[] arr = 地址 该地址指向堆中存储的数据</span><br></pre></td></tr></table></figure></li><li><p>延伸一下，何为基本数据类型，何为引用数据类型</p><ul><li>基本数据类型：数据存储在自己的空间当中，赋值给其他变量的是自己的真实的数据值。 </li><li>引用数据类型：使用new关键字new出来的，数据值存储在其他空间中，自己的空间中存储的是指向其他空间的地址。引用数据类型赋值给其他变量的是地址</li></ul></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li><p>定义和调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void method() &#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line">method()</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>带参数方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void method(int num1 , int num2) &#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br><span class="line">method(10,20 )</span><br></pre></td></tr></table></figure></li><li><p>带返回值的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int method(int a , int b) &#123;</span><br><span class="line">int c = a + b</span><br><span class="line">  return c</span><br><span class="line">&#125;</span><br><span class="line">//返回数组</span><br><span class="line">public static int[] method() &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法的重载：同一个类中，<strong>方法名相同，参数不同的方法</strong>，就是重载。和返回值无关。</p><p>官方定义：多个同名的方法<strong>具有不同的参数类型和参数个数</strong>，这些同名的方法，就构成了重载关系</p></li></ol><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ol><li><p>定义类：一个文件定义一个class类 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Phone() &#123;</span><br><span class="line">//成员变量</span><br><span class="line">String brand;</span><br><span class="line">double price;</span><br><span class="line">//成员方法</span><br><span class="line">public void call()&#123;</span><br><span class="line">system.out.println(&#x27;&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">public void playGame() &#123;</span><br><span class="line"> ........</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建手机对象并使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> //创建对象</span><br><span class="line">Phone p = new Phone();</span><br><span class="line">//使用</span><br><span class="line">p.brand = &#x27;小米&#x27;</span><br><span class="line">.........</span><br></pre></td></tr></table></figure></li><li><p>用来描述一类事物的类不用写main方法，像上面的Phone类，这种类叫做<strong>javabean</strong>类 </p><ul><li>标准的javabean类<ul><li>见名知意</li><li>成员变量使用private关键字，通过get ，set访问</li><li>提供至少两个构造方法<ol><li>无参构造</li><li>带全部参数的构造</li></ol></li></ul></li></ul></li><li><p>封装：告诉你如何正确的设计对象的属性和方法</p></li><li><p>针对private的成员变量，需要提供get和set方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GirlFriend() &#123;</span><br><span class="line">private age;</span><br><span class="line"></span><br><span class="line">public void setAge(a) &#123;</span><br><span class="line">if(a &gt; 18) &#123;</span><br><span class="line">age = a</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">system.out.println(&#x27;不合法&#x27;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public void getAge() &#123;</span><br><span class="line">return age</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>成员变量和局部变量重名</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    private int age; //0</span><br><span class="line">    public void method() &#123;</span><br><span class="line">        int age = 18;  //18</span><br><span class="line">        System.out.println(age);  //age = 18. 就近原则</span><br><span class="line">        System.out.println(this.age) //age = 0  通过this可以访问到外部的成员变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造方法：  </p><ul><li>名字必须和类名相同</li><li>每创建一次对象（实例化），构造函数都会执行一次</li><li>在没写构造方法时，虚拟机默认会添加一个空参构造方法</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">private string name;</span><br><span class="line">private int age;</span><br><span class="line">//空参构造</span><br><span class="line">public Student() &#123;</span><br><span class="line">........</span><br><span class="line">&#125;</span><br><span class="line">//带参构造</span><br><span class="line">public student(String name , int age) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age</span><br><span class="line">.........</span><br><span class="line">&#125;</span><br><span class="line">get set方法.........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main函数中：</span><br><span class="line">//创建对象</span><br><span class="line">Student stu = new Student(&quot;zhangsan&quot; , 18)</span><br><span class="line">System.out.println(stu.getName());</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>对象的内存图</p><ol><li>堆内存只和new关键字有关，有new。那就是创建了一份堆空间</li><li>方法运行时所进入的内存为栈，变量也在这里</li><li>方法区中存储所有的字节码文件，也就是.class文件</li></ol><p>创建对象的步骤：</p><pre><code>     Student s = new Student();     1. 加载class文件     2. 声明局部变量     3. 在堆内存中开辟一份空间     4. 默认初始化     5. 显示初始化（如果JavaBean类在声明成员变量的时候赋值了，那么就需要初始化值）     6. 构造方法初始化     7. 将堆内存中的地址赋值给左边的局部变量</code></pre><p>代码分析：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">String name;</span><br><span class="line">int age;</span><br><span class="line"></span><br><span class="line">public void study() &#123;</span><br><span class="line">System.out.println(&#x27;study&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestStudent&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Student s = new Student();</span><br><span class="line">s.name = &quot;zs&quot;;</span><br><span class="line">s.age = 12;</span><br><span class="line">s.study()</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序执行：</span><br><span class="line">先把TestStudent类加载到方法区，并临时存储main()</span><br><span class="line">执行main函数，main方法被放入栈中</span><br><span class="line">创建Student对象：</span><br><span class="line">先把Student类加载到方法区中，并包含类的所有成员变量以及方法 </span><br><span class="line">Student s被存储到栈中的main方法中</span><br><span class="line">在堆内存中开辟一个空间，把方法区中Student.class的成员变量复制一份，并且堆中还有成员方法的地址 </span><br><span class="line">Student s = 地址 ， 该地址为堆内存中数据的地址</span><br></pre></td></tr></table></figure><p>图片解析： </p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230328202415542.png"></p><p>两个对象的内存图：  </p><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230328202745221.png" alt="image-20230328202745221"></p></li><li><p>this的原理</p><p><strong>前文提到的this可以访问到外部成员变量的原理：</strong>this的本质是代表方法调用者的地址值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Student&#123;</span><br><span class="line">String name;</span><br><span class="line">int age;</span><br><span class="line"></span><br><span class="line">public void study() &#123;</span><br><span class="line">int age = 10</span><br><span class="line">System.out.println(age);</span><br><span class="line">System.out.println(this.age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class TestStudent&#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Student s = new Student();</span><br><span class="line">s.study()</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this指向方法的调用者，也就是s，s在被创建时值为地址，指向的就是堆内存中的数据，所以通过this.name可以获取到成员变量的值</span><br></pre></td></tr></table></figure></li></ol><h2 id="快捷键使用"><a href="#快捷键使用" class="headerlink" title="快捷键使用"></a>快捷键使用</h2><ol><li>快速生成main方法：psvm</li><li>快速生成构造方法：<ul><li>mac快速生成快捷键 command+n。 windows快捷键：alt+insert </li><li>安装插件ptg ，可以快速生成空参构造，全参构造，以及get set方法</li></ul></li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li>在内存中，字符串存储在串池中，串池存储在堆内存中，所以字符串也是引用数据类型</li><li>当使用双引号<strong>直接对字符串变量赋值</strong>时系统会检查该字符串在串池中是否存在，如果不存在，就创建新的，如果存在，复用</li></ol><p>![image-20220825090504378](/Users/hetao/Library/Application Support/typora-user-images/image-20220825090504378.png)</p><ol start="3"><li><p>每new一次就是开辟了一块新的 小空间，相同字符串不会复用 ，所以推荐使用直接赋值的方式，节约内存</p><p>![image-20220825090608673](/Users/hetao/Library/Application Support/typora-user-images/image-20220825090608673.png)</p></li><li><p>string的字符串比较方法：equals（区分大小写），equalsIgnoreCase（不区分大小写）</p></li><li><p>StringBuilder：可以看作是一个容器，创建出来后里面的吗、内容是可以变化的</p><p>​            使用StringBuilder的场景：字符串的拼接，字符串的反转</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建StringBuilder对象，StringBuilder既有无参构造(容器中不初始化值)，也有有参构造</span><br><span class="line">StringBuilder sb = new StringBuilder(&#x27;abc&#x27;)</span><br><span class="line">//添加元素</span><br><span class="line">sb.append(1)</span><br><span class="line">sb.append(2.3)</span><br><span class="line">sb.append(true)   输出为：abc 12.3true</span><br><span class="line">//反转</span><br><span class="line">sb.reverse()</span><br><span class="line">//把StringBuilder类型变成字符串</span><br><span class="line">String str = sb.toString()</span><br><span class="line">//打印的是sb容器中的属性，不是该引用对象的地址值，是因为java底层做的处理</span><br><span class="line">System.out.println(sb)  </span><br></pre></td></tr></table></figure></li><li><p>StringJoiner：和StringBuilder差不多，是个容器，里面的内容也可以变化</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建对象,StringJoiner只有有参构造，第一个参数(必选)为容器中字符串拼接的间隔符号，第二第三个参数(可选)为字符串的开始符号和结束符号</span><br><span class="line">StringJoiner sj = new StringJoiner(&quot;,&quot;,&quot;[&quot;,&quot;]&quot;)</span><br><span class="line">//添加元素</span><br><span class="line">sj.add(&quot;aaa&quot;).add(&quot;bbb&quot;).add(&quot;ccc&quot;)</span><br><span class="line">//输出为[aaa,bbb,ccc ]</span><br><span class="line">System.out.println(sj)  </span><br><span class="line">//变成字符串</span><br><span class="line">sj.toString()</span><br></pre></td></tr></table></figure></li><li><p>toString的底层方法就是new了一个字符串，带变量的字符串拼接（String a = b + “a”）底层就是先使用StringBuilder，在通过toString方法转换成字符串.所以得到的是个新地址值</p></li></ol><h2 id="集合ArrayList"><a href="#集合ArrayList" class="headerlink" title="集合ArrayList"></a>集合ArrayList</h2><ol><li><p>集合：</p><ol><li><p>长度是动态遍变化的，自动伸缩</p></li><li><p>存引用数据类型，如果要存基本数据类型，需要把他们变成对应的包装类 </p></li><li><p>使用：&lt;&gt;代表泛型，用来限制数据类型</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;()</span><br><span class="line">System.out,println(list)   //[]</span><br></pre></td></tr></table></figure></li><li><p>ArrayList是java已经写好的一个类，这个类在底层做了处理，打印的不是地址值，是集合中存储的数据类型。在展示的时候数据会用[ ] 包起来。</p></li><li><p>ArrayList方法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean add(E e)//添加元素，返回值表示是否添加成功</span><br><span class="line">boolean remove(E e)//删除元素，返回值表示是否成功</span><br><span class="line">E remove(int index)//删除指定索引的元素，返回值为被删除的元素</span><br><span class="line">E set(int index , E e)//修改指定索引的元素，返回原来的元素</span><br><span class="line">E get(int index)//获得指定索引的元素</span><br><span class="line">int size()//集合中元素的个数 </span><br></pre></td></tr></table></figure></li><li><p>集合中存放自定义类型的数据</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义了一个Student的javaBean类</span><br><span class="line">public class Student() &#123;</span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">.........</span><br><span class="line">get/set方法</span><br><span class="line">空参构造和全参构造</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用</span><br><span class="line">ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;()</span><br><span class="line"></span><br><span class="line">Student s1 = new Student(&quot;张三&quot;, 18)</span><br><span class="line">list.add(s1)</span><br></pre></td></tr></table></figure></li></ol></li></ol><h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h3><ol><li><p>static关键字，用来修饰成员变量或者成员方法，被static修饰的成员变量被所有实例对象共享</p><figure class="highlight plaintext"><figcaption><span>s</span></figcaption><table><tr><td class="code"><pre><span class="line">//被static修饰的成员变量</span><br><span class="line">public class Student&#123;</span><br><span class="line">.......其他私有成员变量.........</span><br><span class="line">static String teacherName;</span><br><span class="line">.......get/set方法以及成员方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在主函数中（主函数也叫测试类）</span><br><span class="line">main()&#123;</span><br><span class="line">//该属性被所有Student类的实例对象共享</span><br><span class="line">Student.teacherName = &quot;张三&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>static修饰的方法一般写在工具类中，何为工具类？就是帮忙处理功能的类，比如：可以求最大值的工具类，求平均值的工具类，工具类中的构造方法是私有化的，目的为不让外界实例化他的对象，他里面的方法需要定义为static的，方便调用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class AverageUtil()&#123;</span><br><span class="line">private AverageUtil() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">public staic int Average(int[] arr )&#123;</span><br><span class="line">//里面写功能</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>静态方法中没有this关键字,普通函数的this指向调用它的对象，而static方法中没有this，所以会报错</li></ol><p>  <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230328195427351.png" alt="image-20230328195427351"></p><ol start="4"><li>静态方法中不能访问非静态的东西，也就是不能访问非静态方法和非静态变量，在如下的JavaBean类中,method方法为静态方法，其不能访问name和age两个非静态变量，主要原因还是因为其没有this，不知道是哪个对象的name和age。</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.qianrui.staticUse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">static</span> String teacherName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(Student <span class="built_in">this</span>)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;,&quot;</span> + age + <span class="string">&quot;,&quot;</span> + teacherName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>在内存方面，静态的东西随着着类的加载而加载，非静态的东西和对象有关，只要没创建对象，非静态的东西就不会被加载到内存中。</li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol><li>使用extends继承</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>java只支持单继承，也就是一个儿子只能有一个父亲，不支持多继承，但是支持多重继承。</p></li><li><p>每一个类都直接或间接继承于Object类，默认继承。</p></li><li><p>子类只能访问父类非私有的成员</p></li><li><p>子类能继承父类中的哪些内容：</p></li><li><p>构造方法 非私有的不能继承，私有不能继承：因为如果可以继承父类的构造方法，那会导致构造方法和类名不相同。</p></li><li><p>成员变量 非私有能继承，私有能继承：虽然可以继承父类私有的成员变量，但是不能使用。</p></li><li><p>成员方法 非私有能继承，私有不能继承：java会在最顶层的父类设置一个虚方法表（非private方法，非static方法，非final方法），将自己的虚方法存放在虚方法表中，继承其的子类会继承其虚方法表，并在其中添加自己的虚方法，所以使用子类中没有的方法时，并不是一层一层往父类上找，而是先查询虚方法表，如果没有再一层一层往上找。</p></li><li><p>继承的内存图如下所示，在加载子类的字节码文件时，也会将父类的字节码文件加载进方法区</p></li></ol><p>  <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230405140020717.png" alt="image-20230405140020717"></p><p>  <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230405141227208.png" alt="image-20230405141227208"></p><ol start="10"><li><p>继承中成员变量，成员方法，构造方法的访问特点：</p><ol><li>成员变量：就近原则，如果没有重名的成员变量，就直接通过名字访问，如果重名，则要访问本类的，使用this，访问父类的使用super。</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">father</span>()&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;father&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">son</span> <span class="keyword">extends</span> <span class="title class_">father</span>() &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;son&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&#x27;temp&#x27;</span>;           </span><br><span class="line">System.out.println(name);           <span class="comment">//temp  就近原则</span></span><br><span class="line">System.out.println(<span class="built_in">this</span>.name);      <span class="comment">//son   this访问本类成员变量</span></span><br><span class="line">System.out.println(<span class="built_in">super</span>.name);     <span class="comment">//father super代表父类的变量或方法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>成员方法：就近原则，和成员变量访问特点一样。当子类成员方法中的名字和父类成员方法中的名字相同，那就是重写，重写需要写@Override注解（注释是给程序员看的，注释是给虚拟机看得），校验子类重写时语法是否正确。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ublic <span class="keyword">class</span> <span class="title class_">father</span>()&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;eat&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">son</span> <span class="keyword">extends</span> <span class="title class_">father</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.oput.println(<span class="string">&quot;eat food&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>方法重写的原理：B类继承C类的虚方法表，重写method2方法，那么method2方法就属于B的，A继承的虚方法表中的method2为B的method2</p><p> <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230406155825377.png" alt="image-20230406155825377"></p></li><li><p>重写方法的要求：</p><ol><li><p>重写的方法名称，形参列表必须与父类中的一致</p></li><li><p>重写方法的访问权限和返回值类型尽量与父类保持一致</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写方法时，子类的返回值类型大于父类，就会报错，Animal&gt;Dog（范围）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Animals <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只有添加到虚方法表中的方法才能被重写</p></li></ol></li><li><p>构造方法：子类中的构造方法默认先访问父类中的构造方法，再执行自己的，原因是子类在初始化的时候可能会用到父类中的数据，如果父类没有完成初始化，子类将无法使用父类的数据，所以子类在初始化之前先调用父类的构造方法来完成父类数据空间的初始化。因此子类构造方法的第一句就是super(),不写也存在，且必须在第一行，想调用父类的有参构造，必须手写super进行调用传参。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类无参&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认super()</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;子类无参&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();    <span class="comment">//控制台会先输出父类无参，再输出子类无参</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;父类无参&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//默认super()</span></span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;子类无参&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(name , age);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//想要创建学生对象的时候初始化值，就要在Student的有参构造中手动调用super传参</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;zs&#x27;</span> , <span class="number">18</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>this(…)可以访问构造方法，代码如下所示,测试类中调用的无参构造，想要实现如果不赋值，默认名字为张三，则在Student的无参构造中调用有参构造，并赋默认值张三。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>(<span class="string">&quot;张三&quot;</span>, <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span> &#123;</span><br><span class="line">       <span class="built_in">super</span>(name , age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Student</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();  </span><br><span class="line">        System.out.println(st.name); <span class="comment">//张三</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230406164746854.png" alt="image-20230406164746854"></p></li></ol><p>​            </p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><ol><li><p>多态的前提：（1）有继承关系（2）有父类引用子类对象，类似于Father f = new Son()（3）有方法重写</p></li><li><p>多态的好处：使用父类型作为参数，可以接受所有子类对象，提现多态的扩展性与便利</p></li><li><p>多态中调用成员方法，变量的特点：</p><ol><li>调用成员变量：编译看左边，运行也看左边</li><li>调用成员方法：编译看左边，运行看右边</li><li>编译看左边导致多态不能调用子类的特有方法</li></ol> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//多态使用</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="comment">//编译看左边，javac编译代码时，会看左边的父类中有没有这个变量，如果有编译成功，如果没有编译失败</span></span><br><span class="line">        <span class="comment">//运行看左边：多条使用语句Animal a = new Dog();中左边是Animal，所以输出为动物</span></span><br><span class="line">        System.out.println(a.name);<span class="comment">//动物</span></span><br><span class="line">        <span class="comment">//运行看右边：多条使用语句Animal a = new Dog();中左边是Dog，所以输出为狗方法</span></span><br><span class="line">        a.method();<span class="comment">//狗方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;动物&quot;</span>;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;动物方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;狗&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;猫&quot;</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><ol><li>包就是文件夹，包名规则：公司域名+包的作用</li><li>使用同一包中的类不需要导包</li><li>使用java.lang包不需要导包</li><li>其他情况需要导包</li><li>如果同时使用两个包中的同名类，需要使用全类名（包名+类名）</li></ol><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ol><li><p>用final修饰方法：该方法是最终方法，不能被重写</p></li><li><p>用final修饰类：该类是最终类，不能被继承</p></li><li><p>用final修饰变量：叫做常量，只能被赋值一次，final修饰的是基本数据类型，那么变量存储的数据值不能发生改变，如果修饰的变量是引用数据类型，那么存储的地址值不可以发生改变，对象内部可以发生改变。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span>[] ARR = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">ARR[<span class="number">0</span>] = <span class="number">4</span>; <span class="comment">//不会报错</span></span><br><span class="line">ARR = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>]; <span class="comment">//会报错</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h3><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230420145823174.png" alt="image-20230420145823174"></p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ol><li><p>抽象类的作用：当一个父类的两个子类有共同的一个方法，但是方法内容不一样，此时可以在子类中进行方法的重写，但是如果子类的代码不是自己写，而是别人写，别人忘了重写，就会导致子类的该方法与实际不符，所以可以在父类中将该方法定义为抽象方法，这样子类就必须进行重写，不重写就会报错。包含抽象方法的类称为抽象类。</p></li><li><p>抽象方法：子类共同的方法名，但是方法体不一样，在父类中，这种方法可以称为抽象方法。</p></li><li><p>抽象方法定义格式：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名(参数列表)</span><br></pre></td></tr></table></figure></li><li><p>抽象类：一个类中存在抽象方法，则该类必须声明为抽象类。</p></li><li><p>抽象类定义格式</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> class 类名&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象类注意事项：</p><ol><li><p>抽象类不能实例化，也就是Person p = new Person();会报错</p></li><li><p>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</p></li><li><p>抽象类可以有构造方法，作用是当创建子类对象时，给子类对象赋值的,因为虽然父类不能实例化，但是子类如果不是抽象类，是可以实例化的，需要给子类的实例化对象进行赋值。</p></li></ol>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name , <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    pubic <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>;</span><br><span class="line">    get/set...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name , <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name , age)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;zs&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        System.out.println(s.getName() + <span class="string">&#x27;&#x27;</span> + s.getAge());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>抽象类的子类：要么重写抽象类中的所有抽象方法，要么是抽象类</li></ol></li></ol><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ol><li>比如父类为动物类，子类为兔子，狗和青蛙，狗和青蛙有一个公共属性游泳，但是这个属性不能写入父类中，因为不是公共的方法。但是如果各自写入子类当中，就不能规范书写的格式，所以需要定义一个接口来实现。</li></ol><p>  <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230425132849866.png" alt="image-20230425132849866"></p><ol start="2"><li><p>接口就是一种规则，是对行为的抽象。</p></li><li><p>接口的定义和使用：</p></li><li><p>接口使用interface来定义：public interface 接口名 {}</p></li><li><p>接口不能实例化    </p></li><li><p>接口和类之间是实现关系，通过implements关键字表示：public class 类名 implements 接口名 {}</p></li><li><p>类中需要重写接口中的所有抽象方法（类中也要重写父类中的所有抽象方法）</p></li><li><p>接口和类的实现关系可以单实现，也可以多实现：public 类名 implements 接口名1，接口名2 {}</p></li><li><p>当类中实现的多个接口中有重名的抽象方法，只需要重写一次即可。</p></li><li><p>实现类还可以再继承一个类的同时实现多个接口：public 类名 extends 父类 implements 接口名1，接口名2 {}</p></li><li><p>接口与接口也可以继承，可以单继承，也可以多继承（类不能多继承，只能多层继承）</p></li><li><p>代码示例见 ``package com.qianrui.interfaceTest` 包。</p></li><li><p>接口中成员的特点：</p></li><li><p>成员变量:只能是常量,默认修饰符：public static final</p></li><li><p>构造方法:没有构造方法</p></li><li><p>成员方法:只能是抽象方法,默认修饰符：public abstract</p></li><li><p>JDK7以前只能接口中只能定义抽象方法，JDK8之后接口中可以定义有方法体的方法，包括静态方法和默认方法，主要是为了解决接口升级的问题,默认方法格式如下，默认方法注意事项：</p></li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名(参数列表) &#123;&#125;</span><br></pre></td></tr></table></figure><ol><li><p>该方法不是抽象方法，不强制重写，如果被重写，重写时去掉default关键字</p></li><li><p>public可以省略，default不能省略，如果省略了default，默认是抽象方法，抽象方法不能有方法体</p></li><li><p>如果实现了多个接口，多个接口中存在相同名字的默认方法，实现类就必须对该方法进行重写</p></li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//接口1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterA</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InterB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImp</span> <span class="keyword">implements</span> <span class="title class_">InterA</span>,InterB &#123;</span><br><span class="line">    <span class="comment">//不重写就会报错</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">InterImp</span> <span class="variable">ii</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InterImp</span>();</span><br><span class="line">        ii.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<br>​    ```</p><ol start="7"><li> 静态方法，静态方法不能重写</li></ol><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230425163912249.png" alt="image-20230425163912249"></p><ol start="8"><li>JDK9以后新增了私有方法：主要是抽取默认方法或者静态方法中的一些公共代码，格式一是为默认方法服务的，格式二是为静态方法服务的</li></ol><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230425164255107.png" alt="image-20230425164255107"></p><ol start="9"><li><p>接口适配器:当一个接口中有多个方法，我们需要使用其中的一个方法，却需要重写所有抽象方法，不容易一眼看到想要的方法，所以设计接口适配器，在接口适配器中重写所有方法，然后使用实现类继承适配器，重写所需要的方法即可。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Inter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method4</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">method6</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适配器写为抽象类是为了不让外界创建他的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InterAdapter</span> implement inter &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//重写method1-method5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterImpl</span> <span class="keyword">extends</span> <span class="title class_">InterAdapter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method5</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ol><li><p>在类的里面定义的类称为内部类，内部类表示的事物是外部类的一部分，内部类单独出现没有任何意义</p></li><li><p>内部类的访问特点：（1）内部类可以直接访问外部类的成员，包括私有。（2）外部类要访问内部类的成员必须创建对象</p></li><li><p>包括：成员内部类，静态内部类(JDK16之后)，局部内部类，匿名内部类</p></li><li><p>成员内部类</p></li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;外部类</span><br><span class="line">string carName;</span><br><span class="line"><span class="type">int</span> carAge;</span><br><span class="line"><span class="type">int</span> carcolor;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span>&#123;成员内部类</span><br><span class="line">string engineName;</span><br><span class="line"><span class="type">int</span> engineAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>获取成员内部类的对象</p></li><li><p>方法一：</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;外部类</span><br><span class="line">string carName;</span><br><span class="line"><span class="type">int</span> carAge;</span><br><span class="line"><span class="type">int</span> carcolor;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Engine</span>&#123;成员内部类</span><br><span class="line">string engineName;</span><br><span class="line"><span class="type">int</span> engineAge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Car.<span class="type">Engine</span> <span class="variable">en</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>().<span class="keyword">new</span> <span class="title class_">Engine</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方法二：外部类中编写方法，对外提供内部类对象。这种方法当内部类是私有的时候也可以用，上面的方法则不可以。</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;外部类</span><br><span class="line">string carName;</span><br><span class="line"><span class="type">int</span> carAge;</span><br><span class="line"><span class="type">int</span> carcolor;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;成员内部类</span><br><span class="line">string engineName;</span><br><span class="line"><span class="type">int</span> engineAge;</span><br><span class="line">&#125;</span><br><span class="line">                  </span><br><span class="line">     <span class="keyword">public</span> Engine <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Engine</span>();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Car</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>();</span><br><span class="line">        c.getInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/markdownpad/image-20230428193648326.png" alt="image-20230428193648326"></p></li><li><p>静态内部类：只能访问外部类中的静态变量和静态方法，如果想要访问非静态的需要创建对象</p></li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Car</span> &#123;外部类</span><br><span class="line">string carName;</span><br><span class="line"><span class="type">int</span> carAge;</span><br><span class="line"><span class="type">int</span> carcolor;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Engine</span>&#123;静态内部类</span><br><span class="line">string engineName;</span><br><span class="line"><span class="type">int</span> engineAge;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            sout(<span class="string">&quot;非静态方法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="title function_">show1</span><span class="params">()</span> &#123;</span><br><span class="line">            sout(<span class="string">&quot;静态方法&quot;</span>);</span><br><span class="line">        &#125;             </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li><p>静态内部类</p></li><li><p>创建静态内部类对象的格式：外部类名.内部类名 对象名 = new 外部类名.内部类名()</p> <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       Car.<span class="type">Engine</span> <span class="variable">en</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Car</span>.Engine();</span><br><span class="line">        en.show();</span><br><span class="line">        en.show1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用非静态方法的格式：先创建对象，用对象调用</p></li><li><p>调用静态方法的格式：外部类名.内部类名.方法名()</p></li><li><p>局部内部类：定义在方法里面的类称为局部内部类，外界无法使用局部内部类，类似于局部变量，该类可以直接访问外部类的成员，也可以访问方法内的局部变量。</p></li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Outer&#123; 外部类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span>&#123; 局部内部类</span><br><span class="line">            String name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//创建局部内部类的对象</span></span><br><span class="line">    <span class="type">Inner</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    sout(in.name)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="9"><li>匿名内部类：隐藏了名字的内部类</li></ol>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line"><span class="keyword">new</span> 类名或者接口名() &#123;</span><br><span class="line">重写方法；</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//匿名内部类</span></span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">Swim</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">()</span> &#123;</span><br><span class="line">             sout(<span class="string">&quot;重写了swim方法&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="10"><li><p>匿名内部类使用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中调用method方法，之前的方式：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">sout(<span class="string">&quot;吃骨头&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        method(d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的书写方式有点麻烦，使用匿名内部类书写如下,不用再单独定义一个Dog类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        method(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">sout(<span class="string">&quot;吃骨头&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">            &#125;</span><br><span class="line">       );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        a.eat();</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名内部类格式细节：包含了继承和实现，方法重写，创建对象</p></li><li><p>匿名内部类使用场景：当方法的参数是接口或者类时，如上例子所示</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;java跨平台的原因是因为java是运行在虚拟机上的，针对不同的设备安装不同的虚拟机即可&lt;/li&gt;
&lt;li&gt;JVM：java虚拟</summary>
      
    
    
    
    <category term="后端" scheme="https://blog.wxywxy.cn/categories/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="java" scheme="https://blog.wxywxy.cn/categories/%E5%90%8E%E7%AB%AF/java/"/>
    
    
    <category term="后端" scheme="https://blog.wxywxy.cn/tags/%E5%90%8E%E7%AB%AF/"/>
    
    <category term="java" scheme="https://blog.wxywxy.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>动态规划类问题</title>
    <link href="https://blog.wxywxy.cn/2022/10/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B1%BB%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.wxywxy.cn/2022/10/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B1%BB%E9%97%AE%E9%A2%98/</id>
    <published>2022-10-11T03:43:07.000Z</published>
    <updated>2022-10-15T15:12:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是动态规划"><a href="#什么是动态规划" class="headerlink" title="什么是动态规划"></a>什么是动态规划</h4><ul><li>动态规划：类似于数学归纳法，当我们知道n-1的所有情况，那么就可以推出n的情况</li></ul><h4 id="动态规划问题求解步骤"><a href="#动态规划问题求解步骤" class="headerlink" title="动态规划问题求解步骤"></a>动态规划问题求解步骤</h4><ol><li>dp(状态转移)数组以及其下标的含义</li><li>递推公式</li><li>dp数组如何初始化</li><li>遍历顺序</li><li>打印dp数组(检查问题)</li></ol><h4 id="动态规划leetcode题目"><a href="#动态规划leetcode题目" class="headerlink" title="动态规划leetcode题目"></a>动态规划leetcode题目</h4><h5 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a><a href="https://leetcode.cn/problems/fibonacci-number/">斐波那契数列</a></h5><ol><li>i代表第i个斐波那契数，dp[i]代表第i个斐波那契数的值</li><li>dp[i] = dp[i-1] + dp[i-2]</li><li>dp[0] = 0 , dp[1] = 1</li><li>从前向后遍历</li></ol><h5 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">爬楼梯</a></h5><ol><li>i代表第几层，dp[i]代表到达第i层有dp[i]中方法</li><li>dp[i] = dp[i-1] + dp[i-2]</li><li>dp[1] = 1,dp[2] = 2</li><li>从前向后遍历</li></ol><h5 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">不同路径</a></h5><ol><li>dp数组及其含义：dp[i][j]代表到达[i][j]的位置有dp[i][j]种方法</li><li>递推公式：每个位置只能由其上边和左边到达，所以dp[i][j] = dp[i-1][j] + dp[i][j-1]</li><li>初始化数组：由于dp[i][0]和dp[0][j]的位置只能由其上边或者左边到达，所以只有一种方法，故将dp[i][0]和dp[0][j]都初始化为1</li><li>遍历顺序：从行到列</li></ol><h5 id="股票问题III-https-leetcode-cn-problems-best-time-to-buy-and-sell-stock-iii-submissions"><a href="#股票问题III-https-leetcode-cn-problems-best-time-to-buy-and-sell-stock-iii-submissions" class="headerlink" title="[股票问题III][https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/submissions/]"></a>[股票问题III][<a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/submissions/]">https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/submissions/]</a></h5><ol><li>dp数组及其含义：由于限制只能买卖两次，所以每一天的状态包含五种，<ul><li>dp[i][0]表示：第i天啥也不干的所剩最多现金</li><li>dp[i][1]表示：第i天第一次买入股票所剩最多现金</li><li>dp[i][2]表示：第i天第一次卖出股票(完成第一笔交易)所剩最多现金</li><li>dp[i][3]表示：第i天第二次买入股票所剩最多现金</li><li>dp[i][4]表示：第i天第二次卖出股票(完成第二笔交易)所剩最多现金</li></ul></li><li>递推公式<ul><li>dp[i][0] = dp[i-1][0]，第i天啥也不干，所剩最多现金就是前一天啥也不干留下来的最多现金</li><li>dp[i][1] = Math.max(dp[i-1][1] , dp[i-1][0]-prices[i]),第i天状态为第一次买入，所剩最大现金为：前一天第一次买入，今天啥也不干或者昨天啥也没干，买入今天股票</li><li>dp[i][2] = Math.max(dp[i-1][2] , dp[i-1][1]+prices[i]),第i天状态为第一次卖出股票，所剩最大现金为：前一天已经完成第一次交易，今天啥也不干或者昨天第一次买入的状态所剩最大现金加上今天股票的价格</li><li>dp[i][3] = Math.max(dp[i-1][3] , dp[i-1][2]-prices[i])同理</li><li>dp[i][4] = Math.max(dp[i-1][4] , dp[i-1][3]-prices[i])同理</li></ul></li><li>初始化数组：<ul><li>dp[0][0] = 0</li><li>dp[0][1] = -prices[0]</li><li>dp[0][2] = 0 第一天买入又卖出，利润为0</li><li>dp[0][3] = -prices[0] ,第二次买入的状态也为-prices[0],可以理解为第一天买入，卖出，又买入</li><li>dp[0][4] = 0 第一天买入，卖出，又买入，又卖出，利润为0</li></ul></li><li>遍历顺序，直接遍历</li></ol><h5 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h5><h6 id="0-1背包"><a href="#0-1背包" class="headerlink" title="0-1背包"></a>0-1背包</h6><h6 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h6><h6 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h6><p>​    const dp = Array(m).fill().map(item =&gt; Array(n))</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;什么是动态规划&quot;&gt;&lt;a href=&quot;#什么是动态规划&quot; class=&quot;headerlink&quot; title=&quot;什么是动态规划&quot;&gt;&lt;/a&gt;什么是动态规划&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;动态规划：类似于数学归纳法，当我们知道n-1的所有情况，那么就可以推出n的情况&lt;/li&gt;</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.wxywxy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://blog.wxywxy.cn/categories/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="算法" scheme="https://blog.wxywxy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="https://blog.wxywxy.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>私包的开发与上线</title>
    <link href="https://blog.wxywxy.cn/2022/10/10/%E7%A7%81%E5%8C%85%E7%9A%84%E5%BC%80%E5%8F%91%E4%B8%8E%E4%B8%8A%E7%BA%BF/"/>
    <id>https://blog.wxywxy.cn/2022/10/10/%E7%A7%81%E5%8C%85%E7%9A%84%E5%BC%80%E5%8F%91%E4%B8%8E%E4%B8%8A%E7%BA%BF/</id>
    <published>2022-10-10T01:02:22.000Z</published>
    <updated>2022-10-14T06:54:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><ul><li>在项目中使用的私包中的组件需要被二次开发</li></ul><h4 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h4><ol><li>在私包项目中切换到想要开发的组件文件下，打开控制台，执行:<code>npm link</code></li><li>在使用依赖的项目中执行:<code>npm link 依赖名称</code></li><li>这样在依赖中修改代码，项目中就会展现出来</li></ol><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><ul><li>私包项目中执行<code>npm publish</code>进行发布，注意修改版本号。</li><li>将依赖项目的版本号进行相同的更改</li><li>将依赖的项目推上测试分支</li><li>进行测试</li></ul><h4 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h4><ol><li>更改版本号为正式版本号，依赖项目中也需要改</li><li>创建新分支，并push上去</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;在项目中使用的私包中的组件需要被二次开发&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;开发&quot;&gt;&lt;a href=&quot;#开发&quot; class=</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="私包" scheme="https://blog.wxywxy.cn/tags/%E7%A7%81%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript中的class</title>
    <link href="https://blog.wxywxy.cn/2022/10/03/JavaScript%E4%B8%AD%E7%9A%84class/"/>
    <id>https://blog.wxywxy.cn/2022/10/03/JavaScript%E4%B8%AD%E7%9A%84class/</id>
    <published>2022-10-03T03:45:12.000Z</published>
    <updated>2022-10-05T07:53:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><h3 id="对象的创建模式"><a href="#对象的创建模式" class="headerlink" title="对象的创建模式"></a>对象的创建模式</h3><h4 id="Object构造函数模式"><a href="#Object构造函数模式" class="headerlink" title="Object构造函数模式"></a>Object构造函数模式</h4><ul><li>缺点：语句太多</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">p.<span class="property">name</span> = <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">p.<span class="property">age</span> = <span class="number">13</span></span><br><span class="line">p.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">p.<span class="title function_">setName</span>(<span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span> , p.<span class="property">age</span>) <span class="comment">//lisi 13</span></span><br></pre></td></tr></table></figure><h4 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h4><ul><li>如果创建多个对象，有重复代码</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">var</span> p = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;zhangsan&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">13</span>,</span><br><span class="line">  <span class="attr">setName</span>:<span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line">p.<span class="title function_">setName</span>(<span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span> , p.<span class="property">age</span>) <span class="comment">//lisi 13</span></span><br></pre></td></tr></table></figure><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><ul><li>工厂函数：返回一个对象的函数，都可以称为工厂函数</li><li>对象没有个具体的类型，都是Onject类型</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name , age</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    <span class="attr">setName</span>:<span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="title function_">createPerson</span>(<span class="string">&#x27;zhangsan&#x27;</span>,<span class="number">13</span>)</span><br><span class="line"><span class="title function_">createPerson</span>(<span class="string">&#x27;lisi&#x27;</span>,<span class="number">14</span>)</span><br></pre></td></tr></table></figure><h4 id="自定义构造函数模式"><a href="#自定义构造函数模式" class="headerlink" title="自定义构造函数模式"></a>自定义构造函数模式</h4><ul><li>p是Person类型的，每个对象都有其固定的类型</li><li>缺点：每个对象都有相同的setName函数，浪费内存。</li><li>解决方法：将相同的数据放入原型中</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name , age</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zhangsan&#x27;</span> , <span class="number">13</span>)</span><br><span class="line">p.<span class="title function_">setName</span>(<span class="string">&#x27;lisi&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span> , p.<span class="property">age</span>) <span class="comment">//lisi 13</span></span><br></pre></td></tr></table></figure><h4 id="构造函数-原型"><a href="#构造函数-原型" class="headerlink" title="构造函数+原型"></a>构造函数+原型</h4><ul><li>构造函数中只初始化一般函数，相同的函数放入原型当中</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name , age</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">setName</span> = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zhangsan&#x27;</span> , <span class="number">13</span> )</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><ul><li>步骤<ol><li>定义父类型构造函数</li><li>给父类型添加方法</li><li>定义子类型的构造函数</li><li>关键：<strong>创建父类型的实例赋值给子类型的原型</strong></li><li>创建子类型实例，可以调用父类型的方法</li></ol></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 定义父类型构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Father</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">fatherData</span> = <span class="string">&#x27;father data&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2. 给父类型添加方法</span></span><br><span class="line"><span class="title class_">Father</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showFatherData</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">fatherData</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3. 定义子类型的构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sonData</span> = <span class="string">&#x27;son data&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showSonData</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">sonData</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.创建父类型的实例赋值给子类型的原型</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Father</span>()</span><br><span class="line"><span class="comment">//5.创建子类型实例，可以调用父类型的方法</span></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> <span class="title class_">Son</span>()</span><br><span class="line">son.<span class="title function_">showFatherData</span>() <span class="comment">//father data</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//由于son的原型对象指向了Father的实例，所以son.constructor为Father</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son.<span class="property">constructor</span>)<span class="comment">//Father</span></span><br><span class="line"><span class="comment">//但是可以这样修改</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Son</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><ul><li>constructor中的属性为实例对象的属性</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name , age</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello MyName is&#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span> )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span> , <span class="number">13</span>)</span><br><span class="line">p1.<span class="title function_">sayHello</span>()</span><br></pre></td></tr></table></figure><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><ul><li>super是调用父类的构造函数,必须写在子类this之前</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello MyName is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name , age</span>)&#123;</span><br><span class="line">    <span class="variable language_">super</span>(name , age)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">sayAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;My Age is &#x27;</span> + <span class="variable language_">this</span>.<span class="property">age</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;zs&#x27;</span> , <span class="number">13</span>)</span><br><span class="line">stu.<span class="title function_">sayHello</span>() <span class="comment">// Hello MyName is zs</span></span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><ul><li>static声明的属性和方法只能被类调取和使用，和实例对象无关</li><li>所以static所定义的都在类上，其他的属性和方法定义在实例的原型对象上</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> a = <span class="number">0</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> per = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;zs&#x27;</span>, <span class="number">13</span>)</span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">test</span>() <span class="comment">//test</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(per.<span class="property">name</span>, per.<span class="property">age</span>, <span class="title class_">Person</span>.<span class="property">a</span>)<span class="comment">//as 13 0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ES5&quot;&gt;&lt;a href=&quot;#ES5&quot; class=&quot;headerlink&quot; title=&quot;ES5&quot;&gt;&lt;/a&gt;ES5&lt;/h2&gt;&lt;h3 id=&quot;对象的创建模式&quot;&gt;&lt;a href=&quot;#对象的创建模式&quot; class=&quot;headerlink&quot; title=&quot;对象的创建模式</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="知识点" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="class" scheme="https://blog.wxywxy.cn/tags/class/"/>
    
    <category term="继承" scheme="https://blog.wxywxy.cn/tags/%E7%BB%A7%E6%89%BF/"/>
    
    <category term="ES6" scheme="https://blog.wxywxy.cn/tags/ES6/"/>
    
    <category term="ES5" scheme="https://blog.wxywxy.cn/tags/ES5/"/>
    
  </entry>
  
  <entry>
    <title>前端知识</title>
    <link href="https://blog.wxywxy.cn/2022/09/23/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    <id>https://blog.wxywxy.cn/2022/09/23/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/</id>
    <published>2022-09-23T00:48:04.000Z</published>
    <updated>2022-11-30T05:28:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="html"><a href="#html" class="headerlink" title="html"></a>html</h3><h4 id="DOCTYPE作用"><a href="#DOCTYPE作用" class="headerlink" title="DOCTYPE作用"></a>DOCTYPE作用</h4><ul><li>告诉浏览器的解析器应该以什么样的文档标准来解析文档</li><li>文档解析类型：<ul><li>CSS1Compat：标准模式：默认模式，浏览器用W3C的标准来解析渲染页面</li><li>BackCompat：怪异模式：浏览器使用自己的怪异模式来解析渲染页面（不声明就默认这个模式）</li></ul></li></ul><h4 id="script标签中defer和async"><a href="#script标签中defer和async" class="headerlink" title="script标签中defer和async"></a>script标签中defer和async</h4><ol><li>如果script标签中没有这两个属性，浏览器会立即加载并执行指定的脚本，不等待后续的载入的文档，读到就立即加载并执行</li><li>async属性：加载和渲染后续文档的过程和script脚本的加载与执行并行执行（异步）</li><li>defer属性：加载和渲染后续文档的过程和script脚本的加载并行执行，但是脚本的执行在所有元素解析完成之后</li></ol><h4 id="行内，块级元素"><a href="#行内，块级元素" class="headerlink" title="行内，块级元素"></a>行内，块级元素</h4><ul><li>块级元素：div , dl , form , h1~h5 , li , ul , p , table ,ol , td , th , tr</li><li>行内元素：a , img , span , input , textarea , i , strong ， iframe</li><li>区别：行内元素的宽高，上下边距不可设置，由元素的高速决定</li></ul><h4 id="iframe标签"><a href="#iframe标签" class="headerlink" title="iframe标签"></a>iframe标签</h4><ol><li>iframe标签提供了一种简单的方式将网站嵌入页面</li><li>尽量少用iframe标签的原因：<ol><li>iframe标签加载消耗性能，浏览器的onload事件在iframe标签加载完毕后，所以会让别人觉得网页非常慢</li><li>不利于SEO，搜素引擎蜘蛛只会看到框架，而无法找到链接，那该网站就会被判定为死网站。</li></ol></li><li>iframe的利处：<ul><li>可以放一些不用被“蜘蛛”抓取的东西，比如说广告，这样即可以放广告，但是又可以不为广告输送权重，一举两得。</li></ul></li></ol><h4 id="img的title与alt属性"><a href="#img的title与alt属性" class="headerlink" title="img的title与alt属性"></a>img的title与alt属性</h4><ul><li>title：鼠标停留在图片上时显示的信息</li><li>alt：图片无法正常加载时显示的信息</li><li>在SEO层面上，推荐添加上alt属性，因为无法抓取图片，所以需要通过alt来描述这张图的内容</li></ul><h4 id="src与href的区别"><a href="#src与href的区别" class="headerlink" title="src与href的区别"></a>src与href的区别</h4><ul><li>href：用于建立当前页面与引用资源之间的联系，遇到href，浏览器会并行加载后续内容</li><li>src：指向的内容将会嵌入到文档中标签所在位置，浏览器需要加载完src的内容才会继续往下走</li></ul><h4 id="html5语义化"><a href="#html5语义化" class="headerlink" title="html5语义化"></a>html5语义化</h4><ol><li>新增的语义化标签：header , nav , article , section , aside , footer</li><li>语义化的作用：<ol><li>即使没有CSS，页面结构也会很清晰</li><li>有利于SEO，爬虫依据标签来确定上下文和各个关键字的权重</li><li>便于团队开发和维护，语义化具有可读性</li></ol></li></ol><h4 id="lt-strong-gt-lt-b-gt-和-lt-i-gt-lt-em-gt"><a href="#lt-strong-gt-lt-b-gt-和-lt-i-gt-lt-em-gt" class="headerlink" title="&lt;strong&gt;,&lt;b&gt;和&lt;i&gt;,&lt;em&gt;"></a>&lt;strong&gt;,&lt;b&gt;和&lt;i&gt;,&lt;em&gt;</h4><ol><li>&lt;strong&gt;,&lt;b&gt;都表示加粗的意思，&lt;i&gt;,&lt;em&gt;都表示斜体的意思</li><li>&lt;strong&gt;和&lt;em&gt;都属于语义化标签，有利于搜素引擎，而&lt;b&gt;和&lt;i&gt;只是简单的标签</li></ol><h4 id="html5增强表单中新的输入类型属性"><a href="#html5增强表单中新的输入类型属性" class="headerlink" title="html5增强表单中新的输入类型属性"></a>html5增强表单中新的输入类型属性</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;time&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;week&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;month&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="link和-import引入css样式的区别"><a href="#link和-import引入css样式的区别" class="headerlink" title="link和@import引入css样式的区别"></a>link和@import引入css样式的区别</h4><ul><li>加载时机不同：link是html标签，页面加载时link引入的CSS同时被加载，@import引入的CSS在页面加载完毕后加载</li><li>兼容问题：link由于是html标签，所以不存在兼容问题，而@import ie5以上才兼容</li><li>权重问题：link标签样式的权重<strong>大于</strong>@import引入的样式</li></ul><h4 id="web-worker"><a href="#web-worker" class="headerlink" title="web worker"></a>web worker</h4><ol><li><p>web worker是运行在后端的js，独立于其他脚本，不影响页面性能，并通过postMessage将结果传回主线程，</p></li><li><p>使用方式</p><ol><li>创建web worker文件web_worker.js</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">timedCount</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    i=i+<span class="number">1</span>;</span><br><span class="line">    <span class="title function_">postMessage</span>(i);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="string">&quot;timedCount()&quot;</span>,<span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">timedCount</span>();</span><br></pre></td></tr></table></figure><ol start="2"><li>在其他脚本文件中创建web worker对象</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> w;</span><br><span class="line">w = <span class="keyword">new</span> <span class="title class_">Work</span>(<span class="string">&#x27;web_worker.js&#x27;</span>)</span><br><span class="line">w.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(event.<span class="property">data</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="label标签"><a href="#label标签" class="headerlink" title="label标签"></a>label标签</h4><p>直接看下图代码,label的for指向input的id，当点击”男“时也会触发单选框</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span>女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="浏览器不同标签页之间实现通信"><a href="#浏览器不同标签页之间实现通信" class="headerlink" title="浏览器不同标签页之间实现通信"></a>浏览器不同标签页之间实现通信</h4><ol><li>通过cookies ， localstorage等可以存储在浏览器本地的方法</li><li>通过webSocket，webSocket使用方式和web worker差不多，只不过webSocket需要经过一个服务器</li><li>通过shareWorker,shareWorker可以被多个脚本使用，是浏览器所有页面共享的，使用方式和web worker差不多，但是这些标签页面必须是<strong>同源的</strong></li></ol><h4 id="webSocket如何兼容低浏览器"><a href="#webSocket如何兼容低浏览器" class="headerlink" title="webSocket如何兼容低浏览器"></a>webSocket如何兼容低浏览器</h4><ol><li>引入SockJS库，他是JavaScript的一个库，支持websocket的浏览器会优先使用原生的websorcket，如果不支持，则会使用引用的库文件。</li><li>引用<a href="https://so.csdn.net/so/search?q=socket&spm=1001.2101.3001.7020">socket</a>.IO的库文件，这同样是基于时间的双向通信，如何不支持则会使用替代的方案</li></ol><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><h4 id="CSS初始化"><a href="#CSS初始化" class="headerlink" title="CSS初始化"></a>CSS初始化</h4><ol><li><p>初始化原因：由于浏览器兼容问题，不同浏览器对不同标签的默认值时不同的，如果没有CSS初始化，在不同浏览器之间的页面会有差异。初始化CSS样式可以提高编码质量，保持代码的统一性</p></li><li><p>基本的初始化代码</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*&#123;<span class="comment">/*把所有标签的内外边距取消掉*/</span></span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span>&#123;<span class="comment">/*去掉ul的小圆点*/</span></span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span>&#123;<span class="comment">/*把主体设为统一格式*/</span></span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;微软雅黑&quot;</span>;</span><br><span class="line">    <span class="attribute">color</span>:<span class="number">#716f70</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span>&#123;<span class="comment">/*改变a链接的默认格式，颜色和下划线*/</span></span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#716f70</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-class">.hover</span>&#123;<span class="comment">/*改变鼠标经过颜色*/</span></span><br><span class="line">    <span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h4><ol><li>盒子模型包括：内容(content)，内边距(padding)，外边距(margin)，边框(border)</li><li>盒子模型分类：<ol><li>W3C标准盒子模型：属性width和height只包含content，不包含border和padding</li><li>IE盒模型：属性width和height为content+border+padding</li></ol></li><li>通过box-sizing控制，默认值为content-box(W3C盒模型),可取值为border-box(IE盒模型)</li></ol><h4 id="常见的元素隐藏方式"><a href="#常见的元素隐藏方式" class="headerlink" title="常见的元素隐藏方式"></a>常见的元素隐藏方式</h4><ol><li>dislay:none<ul><li>不占空间，会引起回流（重构），且子元素无条件被隐藏</li></ul></li><li>visibility:hidden<ul><li>占空间，会引起重绘，子元素设置visibility：visibile可以被看到</li></ul></li><li>opacity:0<ul><li>占空间，会引起重绘，子元素无条件被隐藏</li></ul></li><li>z-index设为负值，使其位于其他元素下方</li><li>transform:scale(0,0)，将元素缩放为0来隐藏</li></ol><h4 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h4><ul><li><p>当html元素加载前会生成DOM树，CSS会生成Style Rules(样式规则)，这两个都生成后合并在一起生成Render Tree（渲染树），最终通过渲染树展示到页面上</p><ol><li><p>回流：当渲染树的一部分因为元素的尺寸，规模，布局，隐藏等改变而需要重新构建，回流的时候，浏览器会使渲染树中受影响的部分失效，并重构这部分渲染树，完成回流后，浏览器将这部分<strong>重绘</strong>到屏幕中。</p></li><li><p>引起回流的情况：添加或者删除可见的DOM元素，元素位置改变，元素尺寸改变–边距、填充、边框、宽度和高度，内容改变</p></li><li><p>重绘：渲染树中一些元素更新了属性，这些属性不回影响元素布局的，比如背景颜色，字体颜色，只需要重绘即可</p></li><li><p>回流必引起重绘，重绘不一定引起回流</p></li></ol></li></ul><h4 id="BFC-Block-Formatting-Context"><a href="#BFC-Block-Formatting-Context" class="headerlink" title="BFC(Block Formatting Context)"></a>BFC(Block Formatting Context)</h4><ol><li><p>BFC：块级格式化上下文，是CSS的一种渲染机制，BFC就相当于是一个容器，在特定情况下会触发BFC</p></li><li><p>触发BFC条件：</p><ol><li>根元素(body)</li><li>浮动元素 (元素的 float 不是 none)</li><li>绝对定位元素 (元素具有 position 为 absolute 或 fixed)</li><li>内联块,表格单元格,表格标题 (元素display 的值为 inline-blocks、table-cells、table-captions)</li><li>具有overflow 且值不是 visible 的块元素，</li></ol><p> ……</p></li><li><p>BFC的特性：</p><ol><li>计算BFC的高度时，浮动元素也参与计算</li><li>BFC区域不会与float区域重叠</li><li>垂直方向的距离由外边距决定</li></ol><p> ……</p></li><li><p>BFC的使用</p><ol><li><strong>解决子组件浮动，父组件高度塌陷问题</strong>：下面的代码，父组件就会塌陷，给父组件加上overflow:hideen，即可解决，根据触发BFC条件第e条以及BFC特性第a条</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&#x27;box&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&#x27;box1&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    //<span class="attribute">overflow</span>:hidden</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>解决外边距塌陷问题(外边距合并)：</strong>下面这段代码，想象的是box顶格，box1距离顶部20px，但是实际情况是box和box1都距离上方20px，这是因为外边距合并，选取最大的作为外边距。解决方法，给box加上overflow:hideen即可。根据触发BFC条件第e条以及BFC特性第c条</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&#x27;box&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span> = <span class="string">&#x27;box1&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">    //<span class="attribute">overflow</span>:hidden</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">margin-top</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>自适应两列布局:想让box2自适应剩余的宽度，但是实际情况是box2一部分被压在box1下面。实现方法：在box2加上overflow:hideen即可。根据触发BFC条件第e条以及BFC特性第b条</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="comment">/* overflow: hidden; */</span></span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: blue;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="清除浮动-防止高度塌陷"><a href="#清除浮动-防止高度塌陷" class="headerlink" title="清除浮动(防止高度塌陷)"></a>清除浮动(防止高度塌陷)</h4><blockquote><p>子元素浮动后，父元素如果没设置高度，父元素高度就会为0，影响后续布局 </p></blockquote><ol><li><p>给父元素添加高度</p></li><li><p>额外标签法：想要清除谁的浮动就在该标签后面加一个空白标签(为浮动元素添加一个兄弟标签)，设置其样式clear:both</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">clear</span>:both</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>clear:both原理：clear:both的意思为元素左右两边都不允许有浮动元素，所以在box1浮动后，box2应该和box1在一行，但是由于其添加了clear:both,所以box2不能和box1在一行，box2就会换行，此时box1就相当于box2的margin-top，所以父元素的高度就撑开了</p></blockquote><ol start="3"><li><p>给父元素添加overflow:hidden触发BFC方式</p></li><li><p>单伪元素清除法</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span><span class="selector-pseudo">:after</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">clear</span>:both;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">visibility</span>: hidden;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>双伪元素清除法</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span><span class="selector-pseudo">:after</span>,</span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span><span class="selector-pseudo">:before</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: table;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-class">.box</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="comment">/* .box &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-css">            *zoom: 1;  IE浏览器特有属性，代表缩放比例</span></span></span><br><span class="line"><span class="comment"><span class="language-css">&#125; */</span></span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><ol><li><p>vertical-align: middle实现垂直居中，注意事项：</p><ol><li>垂直居中的元素必须是行内块元素</li><li>必须有兄弟元素，且兄弟元素高度为父元素的100%，必须是行内块，必须vertical-align: middle</li><li>如果想要居于屏幕中间，可以在父元素上text-align：center</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: aqua;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>display:flex实现垂直居中,子元素添加上align-self: center属性，意思为在侧轴上的对齐方式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">align-self</span>: center;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>利用伪元素实现垂直居中，道理等同于第一种方法.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">display</span>: inline-block;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>利用隐藏元素实现垂直居中，注意事项：</p><ol><li>要隐藏的节点必须在垂直居中显示的节点的前面</li><li>要隐藏的节点高度为剩余高度的一半</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box2</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">25%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box2&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>利用相对定位实现，注意事项：top的值根据要垂直居中元素的高度占父元素的比例进行计算，保持上下空间大小一样。比如box1高度占比box2为20%，剩下80%上下各40%，所以top就为40%。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">40%</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>利用transform+relative实现，原理：</p><ol><li>先使用相对定位，top：50%，使box1的左上角位于垂直居中位置</li><li>使用transform: translateY(-50%)，使其在Y轴方向上（正负号决定）偏离自身高度的50%。</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>利用绝对定位实现,和相对定位原理一样</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">top</span>: <span class="number">50%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>利用line-height,适合子元素为文本元素，使子元素的line-height等于父元素的高度</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.box1</span> &#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: yellow;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">line-height</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span>ppppppppppppppppppppp<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><ol><li><p>定义动画：</p><p>在每个环节0% ， 20% - 100%中也可以用transform：</p><ul><li>totate：旋转</li><li>skew：扭曲</li><li>scale：缩放</li><li>translate：移动</li><li>matrix：矩阵变形</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">@keyframes 动画名称&#123;</span><br><span class="line">0% &#123;</span><br><span class="line">width:100px</span><br><span class="line">&#125;</span><br><span class="line">100% &#123;</span><br><span class="line">width:200px</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>调用动画</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">div &#123;</span></span><br><span class="line"><span class="language-javascript">  transform-<span class="attr">origin</span>:200px  200px  <span class="comment">//旋转时设置的旋转中心</span></span></span><br><span class="line"><span class="language-javascript">animation-<span class="attr">name</span>:动画名称</span></span><br><span class="line"><span class="language-javascript">animation-<span class="attr">duration</span>:持续时间</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h4><ul><li>important：无限大</li><li>行间：1000</li><li>id：100</li><li>class，属性选择器，伪类：10</li><li>标签，伪元素：1</li><li>通配符(*)，子选择器(&gt;),相邻选择器(+)，同胞选择器(~):0</li><li></li></ul><h4 id="属性继承"><a href="#属性继承" class="headerlink" title="属性继承"></a>属性继承</h4><ol><li>可继承的CSS属性：字号，字体，颜色</li><li>不可继承的属性：边框，内外边距，宽高</li></ol><h4 id="CSS新特性"><a href="#CSS新特性" class="headerlink" title="CSS新特性"></a>CSS新特性</h4><ul><li>border-radius</li><li>box-shadow</li><li>transform</li><li>transition(过渡)</li><li>animation</li><li>media</li></ul><h4 id="CSS单位"><a href="#CSS单位" class="headerlink" title="CSS单位"></a>CSS单位</h4><ul><li><p>em：相当于应用在当前元素的字体尺寸,一些浏览器默认字体大小为16px</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>:<span class="number">20px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>:<span class="number">2em</span>; //就是<span class="number">40px</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>rem：相对于跟元素的字体大小，作用于跟元素，则相对于原始的字体大小，也就是默认的字体大小，作用于非根元素，则相对于根元素的字体大小.</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>:<span class="number">2rem</span> //相对于默认的字体大小(<span class="number">16px</span>),也就是<span class="number">32px</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>:<span class="number">1rem</span>; //相对于根元素字体大小，也就是<span class="number">32px</span></span></span><br><span class="line"><span class="language-css">    <span class="attribute">line-height</span>:<span class="number">2em</span>; //<span class="number">64px</span></span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>vw，vh：1vw = 视窗宽度的1% 1vh = 视窗高度的1%</p></li></ul><h4 id="CSS3新增选择器"><a href="#CSS3新增选择器" class="headerlink" title="CSS3新增选择器"></a>CSS3新增选择器</h4><ol><li>属性选择器<ul><li>element[alt]:所有带alt属性的元素</li><li>element[alt^=’123’]:所有带alt属性且以123开头的元素</li></ul></li><li>结构伪类选择器<ul><li>element:first-child:匹配第一个子元素</li><li>element:first-child:匹配最后一个子元素</li><li>element：nth-child(n):匹配父元素中第N个子元素</li></ul></li><li>伪元素选择器<ul><li>::after</li><li>::before</li><li>注意：<ol><li>创建的是行内元素</li><li>伪元素必须有content属性，可以为空，但是不能没有</li><li>权重为1</li></ol></li></ul></li></ol><h4 id="纯CSS制作三角形"><a href="#纯CSS制作三角形" class="headerlink" title="纯CSS制作三角形"></a>纯CSS制作三角形</h4><ul><li>只要设置宽度就会变成等腰梯形</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">width</span>: <span class="number">0px</span>;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-right</span>: <span class="number">20px</span> solid transparent;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-left</span>: <span class="number">20px</span> solid transparent;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">border-bottom</span>: <span class="number">20px</span> solid greenyellow;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="让谷歌浏览器支持小于12px的文字"><a href="#让谷歌浏览器支持小于12px的文字" class="headerlink" title="让谷歌浏览器支持小于12px的文字"></a>让谷歌浏览器支持小于12px的文字</h4><ol><li><p>zoom属性：放大或缩小图像</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  zoom: <span class="number">0.5</span>; //字体就是<span class="number">6px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>-weblit-transform:scale() ,但是该属性只能作用于可以定义宽高的元素</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  -webkit-<span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>);//<span class="number">6px</span></span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="去除行内元素之间的间距的方法"><a href="#去除行内元素之间的间距的方法" class="headerlink" title="去除行内元素之间的间距的方法"></a>去除行内元素之间的间距的方法</h4><ol><li><p>设置父元素的font-size为0</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>世界<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>世界<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css">  <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">font-size</span>: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">  &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用margin为负值</p></li><li><p>将元素写在同一行(不推荐)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>世界<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>你好<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>世界<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="文本溢出显示省略号"><a href="#文本溢出显示省略号" class="headerlink" title="文本溢出显示省略号"></a>文本溢出显示省略号</h4><ol><li><p>单行文本溢出:</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">overflow</span>: hidden;（文字长度超出限定宽度，则隐藏超出的内容）</span><br><span class="line"><span class="attribute">white-space</span>: nowrap;（设置文字在一行显示，不能换行）</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;（规定当文本溢出时，显示省略符号来代表被修剪的文本）</span><br></pre></td></tr></table></figure></li><li><p>多行文本溢出：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">-webkit-line-clamp: <span class="number">2</span>;（显示的行数）</span><br><span class="line"><span class="attribute">display</span>: -webkit-box;（将对象作为弹性伸缩盒子模型显示 ）</span><br><span class="line">-webkit-box-orient: vertical;（设置伸缩盒子垂直排列 ）</span><br><span class="line"><span class="attribute">overflow</span>: hidden;（文本溢出限定的宽度就隐藏内容）</span><br><span class="line"><span class="attribute">text-overflow</span>: ellipsis;（多行文本的情况下，用省略号 “…” 隐藏溢出范围的文本)</span><br></pre></td></tr></table></figure></li></ol><h4 id="webkit-font-smoothing属性"><a href="#webkit-font-smoothing属性" class="headerlink" title="-webkit-font-smoothing属性"></a>-webkit-font-smoothing属性</h4><ul><li>可以让页面上的字体抗锯齿，字体看起来更清晰</li><li>属性值：<ul><li>none —— 对低像素的文本比较好</li><li>subpixel-antialiased —— 默认值</li><li>antialiased —— 抗锯齿很好</li></ul></li></ul><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><h4 id="ES6语法"><a href="#ES6语法" class="headerlink" title="ES6语法"></a>ES6语法</h4><ol><li>解构赋值</li><li>箭头函数</li><li>扩展运算符</li><li>模板字符串</li><li>Map和Set</li></ol><h4 id="var"><a href="#var" class="headerlink" title="var"></a>var</h4><ul><li>声明的全局变量会直接挂在到window上</li><li>函数内部声明的var变量在函数外部访问不到</li></ul><h5 id="var声明的变量和函数重名问题"><a href="#var声明的变量和函数重名问题" class="headerlink" title="var声明的变量和函数重名问题"></a>var声明的变量和函数重名问题</h5><ol><li>在预编译阶段，优先级<ol><li>参数</li><li>函数声明</li><li>变量声明</li></ol></li><li>函数声明优先级高于变量声明，但并且函数声明不会被变量声明覆盖，但是<strong>会被变量赋值覆盖</strong></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">120</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">//120</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">a</span>()) <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><ol start="3"><li>先声明function a , 由于a已经声明过了，所以var a不会再次声明，但是之后执行a = 120，所以 a变为变量</li></ol><h5 id="函数传入参数与函数内部声明变量重名"><a href="#函数传入参数与函数内部声明变量重名" class="headerlink" title="函数传入参数与函数内部声明变量重名"></a>函数传入参数与函数内部声明变量重名</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">50</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(a)</span><br></pre></td></tr></table></figure><ul><li>v·在编译阶段，<strong>参数提升&gt;函数提升&gt;变量提升，并且每个变量只能被声明一次</strong>，所以在fun函数内部，参数a先声明，var a声明无效，但是赋值语句有效，所以a为50</li></ul><h5 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// function a</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">40</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fun</span>(a)</span><br></pre></td></tr></table></figure><ol><li>在函数内部，由于已经有了参数a，所以var a和function a都不会再次声明，但是函数的赋值会生效，所以a变为函数，因此第一次输出为function，第二次输出由于执行了赋值语句，所以a变为变量，所以第二次输出为40.</li></ol><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>当前作用域总已经存在的变量不会重复声明，但是如果有赋值操作，一定会重新赋值</li><li>var也有自己的作用域</li></ol><h4 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h4><ul><li><a href="https://wxywxy.cn/2022/07/30/JavaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">数组方法总结</a></li><li>find:find方法会返回符合要求的第一个元素，并在找到符合要求的元素后停止遍历，不会对空数组进行遍历，找不到返回undefined</li><li>findIndex：返回的是目标元素的位置，找不到返回-1</li></ul><h4 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h4><ul><li><p>所有<code>引用类型</code>都有一个<code>__proto__(隐式原型)</code>属性，属性值是一个普通的对象</p></li><li><p>所有<code>函数</code>都有一个<code>prototype(原型)</code>属性，属性值是一个普通的对象</p></li><li><p>所有<code>引用类型的__proto__</code>属性<code>指向</code>它<code>构造函数的prototype</code></p></li><li><p>JS在创建对象的时候，都有一个叫做__<strong>proto</strong>__的内置属性，用于指向创建它的函数对象的原型对象prototype。</p></li><li><p>当访问对象上的属性或方法时，如果不存在，就去对象的__<strong>proto</strong>__上去找，如果没有，就去构造函数的prototype的__<strong>proto</strong>__上去查找，直到找到或者undefined，这就是原型链。</p></li><li><p><a href="https://wxywxy.cn/2022/07/22/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/">原型与原型链</a></p></li><li><p>Object.getPrototypeOf(实例对象) === 实例对象.__proto__</p></li></ul><h4 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h4><ul><li>进程：cpu分配资源的最小单位(火车)    </li><li>线程：cpu调度的最小单位(车厢)</li><li>一个进程可以有多个线程，称为多线程，JS是单线程的</li><li>同一进程的线程共享本进程的地址空间和资源，进程之间的资源是独立的</li><li>多线程优点：效率高，缺点：死锁</li><li>线程不共享的资源：<code>栈</code>，<code>寄存器</code>，<code>状态</code>，<code>程序计数器</code></li><li>线程共享的资源：<code>堆</code>，<code>全局变量</code>，<code>静态变量</code></li></ul><h4 id="基础数据类型和包装对象"><a href="#基础数据类型和包装对象" class="headerlink" title="基础数据类型和包装对象"></a>基础数据类型和包装对象</h4><ul><li><p>String，Number，Boolean，null，undefined，symbol</p></li><li><p>包装对象：</p><ol><li><p>将String , Number , Boolean包装成对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> number = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">123</span>)</span><br><span class="line"><span class="keyword">let</span> boolean = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(str) , <span class="title function_">typeof</span>(number) , <span class="title function_">typeof</span>(boolean)) <span class="comment">//object object object</span></span><br></pre></td></tr></table></figure></li><li><p>目的：使得对象可以覆盖javascript所有的值，使其有一个通用的数据模型。并且对象的一些方法也可以直接使用</p></li></ol></li></ul><h4 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h4><ol><li>在堆空间中的分配的内存，未释放和无法释放</li><li>内存泄漏的原因：<ol><li>闭包</li><li>遗忘的定时器</li><li>意外的全局变量<ul><li>JS对未声明的全局变量处理方式是在全局对象上创建该变量的引用，全局对象就是 window 对象。变量在窗口关闭或重新刷新页面之前都不会被释放，如果未声明的变量缓存大量的数据，就会导致内存泄露。</li></ul></li></ol></li><li>优化方法：<ol><li>减少使用闭包</li><li>注意清除定时器</li><li>全局变量先声明后使用</li></ol></li></ol><h4 id="合并对象的方法（合并数组方法见-数组方法"><a href="#合并对象的方法（合并数组方法见-数组方法" class="headerlink" title="合并对象的方法（合并数组方法见 数组方法)"></a>合并对象的方法（合并数组方法见 <a href="https://wxywxy.cn/2022/07/30/JavaScript%E4%B8%AD%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/">数组方法</a>)</h4><ul><li><p>Object.assign()</p><ul><li><p>第一个参数为合并到哪个对象中</p></li><li><p>之后的参数就是要合并的对象</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj3 = &#123;<span class="attr">address</span>:<span class="string">&quot;wuhan&quot;</span>&#125;</span><br><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125; , obj1 , obj2 , obj3)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)  <span class="comment">//&#123;name: &#x27;zhangsan&#x27;, age: 18, address: &#x27;wuhan&#x27;&#125;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h4><ul><li><p>作用：修改this指向</p></li><li><p>区别：传参方式不同</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;全局变量name&quot;</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">age</span> = <span class="string">&quot;全局变量age&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;person中name&quot;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="string">&quot;person中的age&quot;</span>,</span><br><span class="line"><span class="attr">sayHello</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello,MyName is &quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;，MyAge is &quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person1 = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;person1中的name&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="title function_">sayHello</span>()) <span class="comment">//hello,MyName is person中name，MyAge is person中的age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">sayHello</span>.<span class="title function_">apply</span>()) <span class="comment">//hello,MyName is 全局变量name，MyAge is 全局变量age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">sayHello</span>.<span class="title function_">call</span>()) <span class="comment">//hello,MyName is 全局变量name，MyAge is 全局变量age</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">sayHello</span>.<span class="title function_">apply</span>(person1)) <span class="comment">//hello,MyName is person1中的name，MyAge is undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">sayHello</span>.<span class="title function_">apply</span>(person2)) <span class="comment">//hello,MyName is person1中的name，MyAge is undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">sayLike</span>.<span class="title function_">call</span>(person1 , <span class="string">&#x27;study&#x27;</span> , <span class="string">&#x27;sport&#x27;</span>)) <span class="comment">//I am person1中的name I like study And sport</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">sayLike</span>.<span class="title function_">apply</span>(person1 ,[<span class="string">&#x27;study&#x27;</span> , <span class="string">&#x27;sport&#x27;</span>]))<span class="comment">//I am person1中的name I like study And sport</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="null和undefined的区别"><a href="#null和undefined的区别" class="headerlink" title="null和undefined的区别"></a>null和undefined的区别</h4><ul><li>null 是被赋值的，表示啥都没有</li><li>undefined 通常是一个变量已经被声明，但是没有赋值</li><li>null 和 undefined 都是否定值</li><li>typeof(null)=object typeof(undefined) = undefined</li><li>null!==undefined 但是 null= =undefined</li><li>undefined = = false为false null = = false为false</li><li>null运算时被转换成0,但是null = = 0为false，undefined在运算时被转换为NAN</li></ul><h4 id="关于隐式类型转换"><a href="#关于隐式类型转换" class="headerlink" title="关于隐式类型转换"></a>关于隐式类型转换</h4><ol><li><p>字符串和数字比较时，字符串转数字</p></li><li><p>数字与布尔比较时，布尔转数字</p></li><li><p>字符串和布尔比较时，两者转数字</p></li></ol><h4 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h4><ol><li><p>typeof</p><ol><li>对于基本数据类型，除了null（typeof(null)为object），都可以返回正确的结果</li><li>对于引用数据类型，除了function，其他的(Date , RegExp(),数组等)都返回的是原型链最顶端的Object类型</li></ol></li><li><p>instanceof</p><ol><li><p>使用方式：A instanceof B</p></li><li><p>下面代码可以看出，[]即是Array类型，又是Object类型，为什么呢?</p><ul><li>通过原型与原型链可知，[]的隐式原型与Array的显式原型都指向其原型对象</li><li>其原型对象的隐式原型对象与Object的显示原型都指向Object的原型对象，所以<strong>判断两个对象是否属于实例关系</strong>，不能判断一个对象的实例是那种类型。</li><li>其他的归根结题都可以认为是Object的实例</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([]<span class="keyword">instanceof</span> <span class="title class_">Array</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span> <span class="keyword">instanceof</span> <span class="title class_">RegExp</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Date</span> <span class="keyword">instanceof</span> <span class="title class_">Date</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>)  <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Number</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>)  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>constructor</p><ol><li><p>实例对象的constructor指向其构造函数:[].constructor === Array，</p></li><li><p>构造函数prototype属性是由其构造的任何实例继承的属性:Array.prototype.constructor与[].__proto__.constructor都指向Array</p></li><li><p>所以[].__proto__.constructor，Array.prototype.constructor，[].constructor都是Array。但是Array.constructor不是Array是function，原因见d条例</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;123&#x27;</span>.<span class="property">constructor</span> === <span class="title class_">String</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">1</span>) === <span class="title class_">Number</span> <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Error</span>().<span class="property">constructor</span> === <span class="title class_">Error</span>  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>().<span class="property">constructor</span> === <span class="title class_">Date</span>  <span class="comment">//true</span></span><br><span class="line">[].<span class="property">constructor</span> === <span class="title class_">Array</span></span><br></pre></td></tr></table></figure></li><li><p>注意：</p><ul><li>null和undefined是无效的对象，因此不会有constructor存在</li><li>每个构造函数(Array , Number , String , Date….)的隐式原型都指向Function的显示原型，也就是Array.__proto__ === Function.prototype,因为每个构造函数都是Function的实例化对象</li></ul></li></ol></li><li><p>toString</p><ol><li><p>toString是Object原型上的方法</p></li><li><p>使用方式:对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="string">&#x27;123&#x27;</span>)   <span class="comment">// [object String]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([])  <span class="comment">//&#x27;[object Array]&#x27;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><ol><li><p>浅拷贝，复制了一层引用，两者指向同一个值</p></li><li><p>深拷贝，两者毫无关联，互不影响</p></li><li><p>实现深拷贝的方式：</p><ol><li>展开运算符</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;...a&#125;</span><br><span class="line">b.<span class="property">age</span> = <span class="number">19</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">age</span> , b.<span class="property">age</span>) <span class="comment">//18 19</span></span><br></pre></td></tr></table></figure><ol start="2"><li>JSON.parse(JSON.stringify(待拷贝对象))缺点：不能拷贝函数</li><li>slice和concat方法，缺点：只能深拷贝一层,再深层就是浅拷贝了</li><li>jQuery 中的 $.extend (添加true就是深拷贝,不添加就是浅拷贝)</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [[<span class="number">1</span>,<span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> b = []</span><br><span class="line"></span><br><span class="line">$.<span class="title function_">extend</span>(<span class="literal">true</span>,b,a)</span><br><span class="line">b[<span class="number">0</span>].<span class="title function_">push</span>(<span class="number">5</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[<span class="number">0</span>] , b[<span class="number">0</span>]); <span class="comment">//[1,1] [1,1,5]</span></span><br></pre></td></tr></table></figure><ol start="5"><li>手写递归实现</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">extend</span>(<span class="params">origin, deep</span>)&#123;</span><br><span class="line">    <span class="comment">// deep true  启动深拷贝</span></span><br><span class="line">    <span class="comment">// false  浅拷贝</span></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">    <span class="comment">// 数组对象</span></span><br><span class="line">    <span class="keyword">if</span>(origin <span class="keyword">instanceof</span> <span class="title class_">Array</span>)&#123;</span><br><span class="line">        <span class="comment">// 如果是数组，obj就得是数组</span></span><br><span class="line">        obj = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> origin)&#123;</span><br><span class="line">        <span class="keyword">let</span> value = origin[key]</span><br><span class="line">        <span class="comment">// 确定value是不是引用型，前提是deep 是true</span></span><br><span class="line">        obj[key] = (!!deep &amp;&amp; <span class="keyword">typeof</span> value === <span class="string">&quot;object&quot;</span> &amp;&amp; value !== <span class="literal">null</span>) ? <span class="title function_">extend</span>(value, deep) : value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="宏任务与微任务-异步情况下"><a href="#宏任务与微任务-异步情况下" class="headerlink" title="宏任务与微任务(异步情况下)"></a>宏任务与微任务(异步情况下)</h4><ul><li>宏任务：setTimeout，setInterval等网络请求</li><li>微任务：promise ， async/await,process.nextTick(执行顺序高于promise.then)</li><li>微任务在下一轮DOM执行之前执行，宏任务在之后执行</li><li>微任务比宏任务执行快</li></ul><h4 id="事件捕获，冒泡与委托"><a href="#事件捕获，冒泡与委托" class="headerlink" title="事件捕获，冒泡与委托"></a>事件捕获，冒泡与委托</h4><ol><li><p>含义</p><ul><li><p>事件捕获：从window开始，一级一级往下传递，直到触发事件的节点,该阶段不会触发事件</p></li><li><p>事件冒泡：从当前节点开始触发事件，直到window为止</p></li><li><p>事件委托：利用事件冒泡，将子元素的事件绑定到父元素身上，当点击子元素，事件都会冒泡到父元素</p></li></ul></li><li><p>会触发冒泡的事件：click、mouseover、mouseout、keydown、keyup、keypress、mousedown，mousemove、scroll等</p></li><li><p>不会触发冒泡的事件：blur，foucus，mouseenter，mouseleave</p></li><li><p>阻止事件冒泡：event.stopPropagation()</p></li><li><p>阻止默认事件(例如：点击链接自动跳转)：e.preventDefault()</p></li><li><p>在给事件添加监听的函数addEventListener,第三个参数若为false，则支持冒泡，不支持捕获，为true则相反</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">//最后点击子元素输出为 ：父元素 子元素</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> box = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> box1 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;.box1&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  box1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span> , <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;子元素&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125; , <span class="literal">true</span>)</span></span><br><span class="line"><span class="language-javascript">  box.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span> , <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;父元素&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  &#125; , <span class="literal">true</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>事件委托的优缺点</p><ul><li>优点：<ul><li>减少了事件监听器</li><li>减少内存消耗</li><li>为之后添加的子元素动态绑定事件</li></ul></li><li>缺点：<ul><li>事件委托基于事件冒泡，对不冒泡的事件不支持</li><li>层级过多，冒泡过程中会被某层阻止掉</li></ul></li></ul></li></ol><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><ol><li><p>冒泡排序</p><ul><li>复杂度：O(n^2)</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">//控制趟数</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="comment">//控制比较次数，后面排好的不用比较，所以这里要减去i</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; arr.<span class="property">length</span> - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">          <span class="keyword">let</span> temp = arr[j]</span><br><span class="line">          arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">          arr[j+<span class="number">1</span>] = temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sort</span>([<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>]))</span><br></pre></td></tr></table></figure></li><li><p>快速排序</p><ul><li>选一个基准值，比基准值小的放左边，大的放右边,第一趟结束后在两边重复此操作</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">//取中间的数为基准</span></span><br><span class="line">  <span class="keyword">let</span> index = arr.<span class="title function_">splice</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>), <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">let</span> left = []</span><br><span class="line">  <span class="keyword">let</span> right = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; index) &#123;</span><br><span class="line">      left.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      right.<span class="title function_">push</span>(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">sort</span>(left).<span class="title function_">concat</span>([index], <span class="title function_">sort</span>(right))</span><br><span class="line">&#125;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sort</span>([<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure></li><li><p>选择排序</p><ul><li>从未排序的序列中找出最小的与第一个进行交换，之后在剩下的未排序的序列中找最小的与第一个交换，以此类推，直到最后一个元素。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> minIndex</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    minIndex = i</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j = i+<span class="number">1</span>; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> temp = arr[minIndex]</span><br><span class="line">    arr[minIndex] = arr[i]</span><br><span class="line">    arr[i] = temp</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sort</span>([<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure></li><li><p>插入排序</p><ul><li>从未排序的记录中第一个开始，依次与排好序的记录进行比较，找到合适的位置插入</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">//因为第一个是肯定是有序的，所以从下标为1的第二个开始</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = arr[i]</span><br><span class="line">    <span class="keyword">let</span> j = i - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>(key &lt; arr[j]) &#123;</span><br><span class="line">      arr[j+<span class="number">1</span>] = arr[j]</span><br><span class="line">      j--</span><br><span class="line">    &#125;</span><br><span class="line">    arr[j+<span class="number">1</span>] = key</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sort</span>([<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span> , <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure></li><li><p>归并排序</p><ul><li><p>拆分成小块，确保每一部分是有序的</p><p><img src="https://img-blog.csdnimg.cn/fa1d7020de1148da8f9a54ab79ee62e8.gif#pic_center" alt="图示"></p></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = []</span><br><span class="line">  <span class="keyword">while</span> (left.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; right.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt; right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(left.<span class="title function_">shift</span>())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(right.<span class="title function_">shift</span>())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.<span class="title function_">concat</span>(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sort</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> mid = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> left = <span class="title function_">sort</span>(arr.<span class="title function_">slice</span>(<span class="number">0</span>, mid))</span><br><span class="line">  <span class="keyword">var</span> right = <span class="title function_">sort</span>(arr.<span class="title function_">slice</span>(mid))</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(left, right)</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sort</span>([<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">6</span>]))</span><br></pre></td></tr></table></figure></li></ol><h4 id="document-onload和document-ready"><a href="#document-onload和document-ready" class="headerlink" title="document.onload和document.ready"></a>document.onload和document.ready</h4><ul><li>区别：read表示文档已经加载完成(不包含图片等非文字文件)，onload是指页面包括图片等文件在内的所有元素都加载完成。</li></ul><h4 id="通过new创建对象的过程"><a href="#通过new创建对象的过程" class="headerlink" title="通过new创建对象的过程"></a>通过new创建对象的过程</h4><ol><li>内存中创建一个空对象</li><li>this指向该空对象</li><li>继承该函数的原型</li><li>属性和方法加入到this引用的对象中</li><li>新创建的对象由this所引用。</li></ol><h4 id="箭头函数与普通函数区别"><a href="#箭头函数与普通函数区别" class="headerlink" title="箭头函数与普通函数区别"></a>箭头函数与普通函数区别</h4><ul><li><p>箭头函数是匿名函数，普通函数可以是匿名函数，也可以是具名函数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//普通函数匿名函数</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></li><li><p>箭头函数不能用于构造函数，普通函数可以用于构造函数，以此来创建实例</p></li><li><p>普通函数中this指向调用他的对象，箭头函数中this指向外层作用域的this</p></li><li><p>箭头函数不具有arguments对象，没有prototype原型对象，没有event.target</p></li></ul><h4 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h4><ul><li><p>全局作用域和普通函数调用，this指向window</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> test2 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()<span class="comment">//window</span></span><br><span class="line"><span class="title function_">test2</span>()<span class="comment">//window</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>)<span class="comment">//window</span></span><br></pre></td></tr></table></figure></li><li><p>方法中的this，谁调用该方法，this就指向谁</p></li><li><p>构造函数中的this指向构造函数的实例化对象</p></li><li><p>箭头函数中this指向外层作用域的this</p></li><li><p>call，apply的调用</p></li></ul><h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><ol><li><p>Promise构造函数是同步的，then方法是异步的.下面代码输出为1 2 5 4 3，原因：</p><ol><li>promise属于同步，所以直接输出1 2</li><li>then是异步的，但是是微任务，settimeout是宏任务，所以先输出4，再输出3</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line"> &#125;, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>);</span><br><span class="line">&#125;)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></li><li><p><a href="https://wxywxy.cn/2022/07/15/Promise%E7%9A%84%E5%B0%81%E8%A3%85/">Promise封装</a>方法封装 </p></li><li><p>Promise.all方法</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve , reject</span>) =&gt;</span> &#123; </span><br><span class="line"><span class="title function_">resolve</span>(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;OK&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="string">&#x27;no problem&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> result = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1 , p2 , p3])</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">//PromieState:&quot;fulfilled&quot; PromiseResult:[&#x27;p1&#x27; , &#x27;OK&#x27; , &#x27;no problem&#x27;]</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="property">all</span> = <span class="keyword">function</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve , reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//用来计数</span></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">    <span class="comment">//用来存储结果</span></span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="comment">//对数组中每个Promise对象进行遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      arr[i].<span class="title function_">then</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//如果是成功的，count++</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        res[i] = v</span><br><span class="line">        <span class="comment">//当count等于数组的长度，说明全部成功了，直接返回成功</span></span><br><span class="line">        <span class="keyword">if</span>(count === arr.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="title function_">resolve</span>(res)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,<span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//有一个失败了，直接返回失败的数据</span></span><br><span class="line">        <span class="title function_">reject</span>(r)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。我认为的Promise就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。有三种状态 pending resolved rejected。pending 等待  处于unsettled阶段,表示事情还在等待最终的结果。resolved 已处理  处于setteled阶段，表示事情已经出现结果，并且可以按照正常的逻辑进行下去的结果。rejected 已拒绝 处于setteled阶段，表示事情已经出现结果，并且不可以按照正常的逻辑进行下去的结果</p></li></ol><h4 id="Promise与async，await的区别"><a href="#Promise与async，await的区别" class="headerlink" title="Promise与async，await的区别"></a>Promise与async，await的区别</h4><ul><li>Promise的出现通过链式调用，解决了回调地狱的问题，但是如果业务场景较复杂，这样写也不美观，async与await可以让异步代码看起来像同步代码，使代码更简洁，并且可以使用try-catch对错误进行处理，async-await在Promise的基础上进一步进行了优化。</li></ul><h4 id="for-in与for-of的区别"><a href="#for-in与for-of的区别" class="headerlink" title="for-in与for-of的区别"></a>for-in与for-of的区别</h4><ol><li>for-in:适合对对象进行遍历，遍历的是对象的key值，如果对数组进行遍历，遍历的是索引</li><li>for-of:遍历的是元素值，并且不能遍历对象，只能遍历数组</li></ol><h4 id="字符串-数组"><a href="#字符串-数组" class="headerlink" title="字符串-数组"></a>字符串-数组</h4><ol><li>字符串-&gt;数组<ul><li>string.split(‘’)</li></ul></li><li>数组-&gt;字符串<ul><li>array.join(‘’)</li></ul></li></ol><h4 id="Map的方法"><a href="#Map的方法" class="headerlink" title="Map的方法"></a>Map的方法</h4><ul><li>map是由key-value组成的集合</li><li>定义：const map = new Map()</li><li>map方法<ol><li>map.get(key):通过key获取对应的value</li><li>map.set(key , value):向map中添加元素</li><li>map.values():返回一个新的Iterator对象，该对象中的内容为map中的每一个value</li></ol></li></ul><h4 id="原生AJAX请求的步骤"><a href="#原生AJAX请求的步骤" class="headerlink" title="原生AJAX请求的步骤"></a>原生AJAX请求的步骤</h4><ol><li>实例化XMLHttpRequest对象</li><li>建立连接</li><li>监听服务器对象</li><li>发送请求</li><li>获取数据</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>() <span class="comment">//1. 创建XMLHttpRequest对象</span></span><br><span class="line">http.<span class="title function_">open</span>(<span class="string">&#x27;get&#x27;</span> , <span class="string">&#x27;http://baidu.com&#x27;</span>) <span class="comment">//2.建立连接</span></span><br><span class="line"><span class="comment">//3.监听服务器响应</span></span><br><span class="line">http.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//5.获取返回数据</span></span><br><span class="line">  <span class="keyword">if</span>(http.<span class="property">readystate</span> === <span class="number">4</span> &amp;&amp; http.<span class="property">status</span> === <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> data = http.<span class="title function_">responseText</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.发送请求</span></span><br><span class="line">http.<span class="title function_">send</span>()</span><br></pre></td></tr></table></figure><h4 id="同源策略和跨域"><a href="#同源策略和跨域" class="headerlink" title="同源策略和跨域"></a>同源策略和跨域</h4><ol><li>同源策略：<strong>浏览器</strong>最核心，最基本的安全功能，协议，域名，端口，三者一样即为同源，否则为跨域</li><li>跨域请求可以到达服务器，浏览器也可以接收到服务器返回的数据，只是由于跨域，所以将浏览器数据丢弃了。</li></ol><h4 id="异步加载的方式"><a href="#异步加载的方式" class="headerlink" title="异步加载的方式"></a>异步加载的方式</h4><ol><li>defer</li><li>async</li><li>动态创建script标签</li><li>通过Jquery的$(document).ready(callback())</li><li>通过window.onload = callback()，onload事件在整个页面加载完毕后触发</li></ol><h4 id="Map方法"><a href="#Map方法" class="headerlink" title="Map方法"></a>Map方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map中的一对key-value a:1,b:2</span></span><br><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>([[a,<span class="number">1</span>],[b,<span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h4 id="函数柯里化和闭包"><a href="#函数柯里化和闭包" class="headerlink" title="函数柯里化和闭包"></a>函数柯里化和闭包</h4><ol><li>闭包的应用：柯里化函数</li></ol><h4 id="url从浏览器到页面的过程"><a href="#url从浏览器到页面的过程" class="headerlink" title="url从浏览器到页面的过程"></a>url从浏览器到页面的过程</h4><ol><li>输入URL</li><li>浏览器解析域名得到服务器IP地址<ul><li>查找浏览器缓存，如果存在直接取出</li><li>查找本地DNS缓存</li><li>不存在，访问DNS域名解析器得到IP地址</li></ul></li><li>TCP三次握手建立连接</li><li>客户端发送请求</li><li>服务器响应请求，并发送数据给客户端</li><li>TCP四次挥手关闭连接</li><li>浏览器解析资源并渲染页面<ul><li>html资源-&gt;DOM tree</li><li>CSS资源-&gt;style rules tree</li><li>js通过相应API操作DOM树和style tree</li><li>解析完成后生成render tree</li><li>调用操作系统GUI完成绘制</li></ul></li></ol><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><ol><li>事件循环过程描述:</li><li>函数入栈，当Stack执行到异步任务时，将他丢给WebAPIs，接着执行同步任务到栈空</li><li>在此期间，WebAPIs完成这个事件，把回调函数放入CallBackQueue中(任务队列中)等待</li><li>当执行栈为空时，EvenLoop把CallbackQuene中的一个任务放入Stack中，回到第一步</li><li>作用：事件循环(EvenLoop)是让javascript做到既是单线程，又绝不会阻塞的核心机制，也是JS并发模型的基础</li></ol><h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><ol><li>垃圾回收就是间歇的不定期的寻找不在使用的变量,并释放掉他们所指向的内存</li><li>作用:防止内存泄漏</li><li>垃圾回收方式:标记清除,引用计数</li></ol><h4 id="KMP中next数组的求法"><a href="#KMP中next数组的求法" class="headerlink" title="KMP中next数组的求法"></a>KMP中next数组的求法</h4><ol><li><p>通过前缀和后缀子串的最长公共长度</p><table><thead><tr><th>下标</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>数组</td><td>a</td><td>b</td><td>a</td><td>a</td><td>b</td><td>c</td><td>c</td><td>a</td></tr><tr><td>next</td><td>0</td><td>1</td><td>1</td><td>2</td><td>2</td><td>3</td><td>1</td><td>1</td></tr></tbody></table><table><thead><tr><th>字串</th><th>最长公共长度</th></tr></thead><tbody><tr><td>ab</td><td>0（下标为3位置为0+1）</td></tr><tr><td>aba</td><td>1（下标为4位置为1+1）</td></tr><tr><td>abaa</td><td>1</td></tr><tr><td>abaab</td><td>2</td></tr><tr><td>abaabc</td><td>0</td></tr><tr><td>abaabcc</td><td>0</td></tr></tbody></table></li><li><p>通过前一位的next数组进行推理</p><ul><li>默认情况下下标1，2的next数组默认为0，1</li><li>下标为3的next数组的值看前一位下标为2的next数组的值，为1，判断下标为2和下标为1的两个数组值是否相等，如果想等，下标为3的next值为下标为2的next值加一，如果不等，找出下标1的next指向的数组值，再次进行判断，由于a的next为0，所以到头了，都不匹配，则为1</li><li>下标为4的前一位a的下标为1，指向a，a===a，所以下标4的next数组值为下标3的next数组值加1，为2</li><li>下标为5的前一位a(下标为4)的next为2，指向b，a!==b，，b的下标指向下标为1的a，下标为4的a等于下标为1的a，所以下标为5的next值为下标为2的next值加一，为2</li><li>下标为6的前一位b的next指向下标为2的b，b===b,所以其next为3</li><li>剩下下标为7和8都是判断到第一位，也没有<strong>和其前一位相等</strong>的，所以都为1</li></ul></li></ol><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><h4 id="Vue的优缺点"><a href="#Vue的优缺点" class="headerlink" title="Vue的优缺点"></a>Vue的优缺点</h4><ol><li>优点<ol><li>双向数据绑定</li><li>组件化开发：把页面拆分成多个组件，每个组件依赖的CSS，JS，模板等资源放在一起。</li><li>单页面路由：页面跳转通过路由实现，不用请求服务器</li><li>虚拟DOM：每次更新通过比对前后两次的虚拟DOM，减少更新代价</li><li>渐进式框架：需要什么功能再去添加想要的功能，循序渐进</li></ol></li><li>缺点：<ol><li>首屏幕加载慢</li><li>由于DOM都是在客户端生成，所以蜘蛛在爬取的时候爬不到东西，不利于SEO</li></ol></li></ol><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><ol><li>创建一个vue流程<ol><li>new vue(),开始创建一个Vue实例对象</li><li>Init() Event&amp;LifeStyle,刚初始化了一个vue实例对象，这个实例身上此时只有一些生命周期函数和默认事件，其他的东西都未创建</li><li>beforeCreate()钩子：此时data和method中的数据还没初始化</li><li>Init() injections&amp;reacitive,初始化数据和方法</li><li>created()钩子：此时data和method中的数据已经被初始化好了，所以需要调用method中的方法和操作data中的数据，最早只能在created中</li><li>编译模板，并未挂载到页面中</li><li>beforeMounted()钩子：此时，模板已经编译完成，但是尚未挂载，此时页面还是旧的</li><li>编译好的模版挂载到页面中</li><li>mounted()钩子：操作DOM节点，最早在mounted中</li><li>beforeUpdate()钩子：页面中的数据还是旧的，但是data中的数据是新的，知识还没渲染到页面</li><li>updated()钩子：更新完毕，数据和页面同步</li><li>beforeDestory()钩子：vue实例进入销毁阶段，但是身上的所有东西都还可用，可以销毁定时器啥的</li><li>destoryed()钩子：此时已经被销毁，所有的指令方法，数据都不可用</li></ol></li></ol><h4 id="改变数组的方法"><a href="#改变数组的方法" class="headerlink" title="改变数组的方法"></a>改变数组的方法</h4><ul><li>push，pop，shift，unshift</li></ul><h4 id="更改数据的方法"><a href="#更改数据的方法" class="headerlink" title="更改数据的方法"></a>更改数据的方法</h4><ul><li>在vue中直接修改数据，是不会被监听到的，所以页面也不会更新</li><li>方法一：Vue.set()</li><li>方法二：this(vm).$set()</li></ul><h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><ul><li><p>父传子：props</p></li><li><p>父传子孙：provide，inject</p><ul><li>父组件配置项：provide:{foo:123}</li><li>孙子组件配置项inject:[‘foo’]</li></ul></li><li><p>子传父：$emit</p></li><li><p>事件总线：$emit(触发事件)和$on(绑定事件)</p></li><li><p>vuex</p></li><li><p>订阅发布</p></li></ul><h4 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h4><ol><li><p>vue-router钩子</p><ul><li><p>beforeRouterEnter(to , from , next)</p></li><li><p>beforeRouterUpdate</p></li><li><p>beforeRouterLeave</p></li></ul></li><li><p>vue-router组件</p><ol><li>&lt;router-link&gt;:路由声明式跳转</li><li>&lt;router-view&gt;:渲染路由的容器</li><li>&lt;keep-alive&gt;:缓存组件</li></ol></li><li><p>vue-router的实现原理：通过window.addEventListener()方法监听页面地址的变化</p></li><li><p>$router和$route</p><ol><li>$router是vue-router的一个实例，是用来操作路由的，包含了路由跳转方法，钩子等</li><li>$route是用来获取路由信息的</li></ol></li><li><p>路由传参</p><ol><li><p>params</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/123&#x27;</span>,</span><br><span class="line"><span class="attr">params</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:<span class="number">2</span>,</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;zs&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="property">params</span>.<span class="property">id</span></span><br></pre></td></tr></table></figure></li><li><p>query</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line"><span class="attr">path</span>:<span class="string">&#x27;/123&#x27;</span>,</span><br><span class="line"><span class="attr">query</span>:&#123;</span><br><span class="line"><span class="attr">id</span>:<span class="number">2</span>,</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;zs&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$router</span>.<span class="property">query</span>.<span class="property">id</span></span><br></pre></td></tr></table></figure></li><li><p>区别：query传参，name和path都行，url会带上参数，params传参只能是name，url不会带上参数，刷新就没有了</p></li></ol></li></ol><h4 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h4><ul><li>将数据绑定在VM上，会自动将数据渲染到页面中(model-&gt;view)，视图变化又会通知VM更新数据(view-&gt;model)，ViewModel就是一座桥梁，通过双向数据绑定把 View 层和 Model层连接了起来，而View和 Model 之间的同步工作完全是自动的，无需人为干涉。</li></ul><h4 id="computed，methods，watch"><a href="#computed，methods，watch" class="headerlink" title="computed，methods，watch"></a>computed，methods，watch</h4><ol><li>computed与methods<ol><li>computed是属性调用，nethods是函数调用</li><li>computed带有缓存功能，只有当计算属性所依赖的属性发生改变时，才会重新计算。methods不会被缓存。</li></ol></li><li>computed与watch<ol><li>watch是观察某一属性的变化，然后进行具体的业务逻辑或重新计算属性值</li><li>computed是通过所依赖的属性的变化重新计算属性值</li><li>两者区别不大，一般使用computed，但是当数据变化时需要进行异步操作或者开销较大，推荐使用watch</li></ol></li></ol><h4 id="v-show与v-if"><a href="#v-show与v-if" class="headerlink" title="v-show与v-if"></a>v-show与v-if</h4><ol><li>v-if：动态的添加或删除DOM节点，在初始渲染条件为假时，什么也不做，切换消耗大，适合在权限列表的展示中使用，因为使用v-show在网页源码中还是能够显示。</li><li>v-show：通过设置元素的display样式来实现显示和隐藏，不论初始渲染条件是啥，元素都会被编译，只是简单进行CSS的切换，初始渲染消耗大。</li></ol><h4 id="v-for与v-if"><a href="#v-for与v-if" class="headerlink" title="v-for与v-if"></a>v-for与v-if</h4><ol><li>避免一起使用：因为在vue2中v-for优先级高于v-if，使用会造成性能的浪费</li><li>如果非要一起使用，可以使用以下两种方法<ol><li>v-if的数据不依赖于v-for中的数据：将v-if写在外层</li><li>v-if的数据依赖于v-for中的数据：使用计算属性将v-for中的属性先过滤一次</li></ol></li></ol><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><ol><li>引入keep-alive，页面第一次加载触发created-&gt;mounted-&gt;activated(keep-alive组件激活时调用activated)钩子，退出时触发deactivated(组件失活时调用)。再次进入只触发activated。</li><li>keep-alive的include和exclude可以通过组件的name指定使用缓存或者不使用缓存</li><li>作用：在组件切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性。</li></ol><h4 id="hash路由和history路由的区别"><a href="#hash路由和history路由的区别" class="headerlink" title="hash路由和history路由的区别"></a>hash路由和history路由的区别</h4><ul><li>hash：hash路由利用了window可以监听onhashchange事件来实现的，也就是说hash值指导浏览器动作时，不会请求服务器，http请求中也不会包括hash值，同时每一次改变 hash 值，都会在浏览器的访问历史中增加一个记录，使用“后退”按钮，就可以回到上一个位置。所以，hash 模式 是根据 hash 值来发生改变，根据不同的值，渲染指定DOM位置的不同数据。</li><li>history： 利用了HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法，这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会向后端发送请求<ul><li>back()：后退到上一个路由；</li><li>forward()：前进到下一个路由，如果有的话；</li><li>go(number)：进入到任意一个路由，正数为前进，负数为后退；</li><li>pushState(obj, title, url)：前进到指定的 URL，不刷新页面；</li><li>replaceState(obj, title, url)：用 url 替换当前的路由，不刷新页面；</li></ul></li><li>区别<ol><li>hash路由带有#号，history没有</li><li>history路由使用了H5的新API，因此对浏览器版本有要求</li><li>pushState设置的新URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL;</li><li>pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串;</li><li>pushState可额外设置title属性供后续使用;</li><li>hash兼容IE8以上，history兼容IE10以上;</li><li>history模式需要后端配合将所有访问都指向index.html，否则用户访问二级页面，刷新页面，会导致404错误。要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面</li></ol></li></ul><h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><ol><li><p>普通插槽</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//子组件son</span><br><span class="line">&lt;div&gt;早&lt;/div&gt;</span><br><span class="line">&lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">&lt;div&gt;好&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//父组件</span><br><span class="line">&lt;son&gt;</span><br><span class="line">  &lt;div&gt;上&lt;/div&gt;</span><br><span class="line">&lt;/son&gt;</span><br></pre></td></tr></table></figure></li><li><p>具名插槽</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//子组件son中</span><br><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">      &lt;slot name = &#x27;header&#x27;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">   &lt;slot name = &#x27;footer&#x27;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">//父组件中</span><br><span class="line">&lt;son&gt;</span><br><span class="line">&lt;template v-slot:header&gt;</span><br><span class="line">&lt;h1&gt;title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  &lt;template v-slot:default&gt;</span><br><span class="line">&lt;div&gt;content&lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">&lt;div&gt;footer&lt;/div&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/son&gt;</span><br></pre></td></tr></table></figure></li></ol><h4 id="package-json中-和-的区别"><a href="#package-json中-和-的区别" class="headerlink" title="package.json中^和~的区别"></a>package.json中^和~的区别</h4><ol><li>^的意思是将版本更新到第一个数字的最新版本</li><li>~的意思是将版本更新到中间数字的最新版本</li></ol><h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><ol><li><p>页面权限：通过路由中的meta字段和路由守卫进行实现</p></li><li><p>按钮权限：</p><ol><li><p>自定义指令：包装一个自定义指令，在自定义指令中进行权限的判断，</p><ul><li><p>先获取按钮权限表</p></li><li><p>如果指令传值，就获取参数，参数和按钮权限比较</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">src/utils/direction文件</span><br><span class="line"><span class="comment">//自定义指令 </span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserAuthList</span> = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;button_admin&#x27;</span>])</span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;auth&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>:<span class="keyword">function</span>(<span class="params">el, binding, vnode</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="title class_">UserAuthList</span>.<span class="title function_">has</span>(binding.<span class="property">value</span>)) &#123;</span><br><span class="line">      el.<span class="property">parentNode</span> &amp;&amp; el.<span class="property">parentNode</span>.<span class="title function_">removeChild</span>(el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">main.<span class="property">js</span>文件</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/utils/direction&#x27;</span></span><br><span class="line"></span><br><span class="line">权限判定文件</span><br><span class="line">&lt;button v-auth=<span class="string">&quot;&#x27;button_admin&#x27;&quot;</span>&gt;测试admin&lt;/button&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-auth</span>=<span class="string">&quot;&#x27;button_user&#x27;&quot;</span>&gt;</span>测试user<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">结果</span><br><span class="line">页面只展示测试admin按钮</span><br></pre></td></tr></table></figure></li><li><p>如果没有指令传值，通过路由信息中的meta与按钮权限呢比较</p></li></ul></li></ol></li></ol><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><h4 id="生命周期-新"><a href="#生命周期-新" class="headerlink" title="生命周期(新)"></a>生命周期(新)</h4><ol><li>初始化阶段<ol><li>constructor<ul><li>接收props和context，想在函数内部使用这两个参数时，需要在super传入参数，使用constructor必须使用super，不然会有this指向问题。如果不使用这两个参数，可以不使用constructor</li></ul></li><li>getDerivedStateFromProps</li><li>render</li><li>componentDidMount    开始监听,发送ajax请求</li></ol></li><li>update<ol><li>shouldComponentUpdate(nextProps, nextState)</li><li>render</li><li>componentDidUpdate</li></ol></li><li>unmount<ol><li>componentWillUnmount</li></ol></li></ol><h4 id="生命周期-旧"><a href="#生命周期-旧" class="headerlink" title="生命周期(旧)"></a>生命周期(旧)</h4><ol><li>constructor()—构造器</li><li>componentWillMount()—将要挂载  废弃</li><li>render()</li><li>componentDidMount()</li><li>shouldComponentUpdate</li><li>componentWillUpdate  废弃</li><li>render</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ol><h4 id="类组件和函数式组件区别"><a href="#类组件和函数式组件区别" class="headerlink" title="类组件和函数式组件区别"></a>类组件和函数式组件区别</h4><ol><li>类组件可以有状态管理和生命周期钩子等特性,并且有this,又叫做有状态组件</li><li>函数式组件没有生命周期钩子,但是有hooks.不能使用this,又叫做无状态组件</li><li>函数式组件性能高于类式组件,因为类式组件使用需要实例化,函数式组件直接执行取返回值即可</li></ol><h4 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h4><ul><li><p>fiber的作用：使得动画和页面交互更加的顺畅</p></li><li><p>fiber的出现：</p><ul><li>react16之前，对比更新虚拟DOM是通过循环+递归实现的，但是递归一旦开始就无法终止，如果组件数量庞大，主线程被长期占用，直到整个虚拟DOM树对比更新完成后才会释放，主线程才能执行渲染任务，这就会导致渲染的推迟，1s就达不到60帧，造成页面的卡顿。解决方法：<ol><li>利用浏览器空暇时间执行任务，拒绝长时间占用主线程</li><li>放弃递归，只采用循环，因为循环可以被中断</li><li>任务拆分成一个个小任务</li></ol></li></ul></li><li><p><strong>何为fiber</strong></p><ol><li><p>Fiber其实是一种数据结构，他可以用一个纯JS对象来表示</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fiber = &#123;</span><br><span class="line">  stateNode,  //节点实例</span><br><span class="line">  child,      //子节点</span><br><span class="line">  sibling,    //兄弟节点</span><br><span class="line">  return,     //父节点</span><br><span class="line">  .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fiber还是一个执行单元，每次执行完一个执行单元，React就会检查现在还剩多少时间，如果没有时间就将控制权让出去。</p></li><li><p>关键特性</p></li><li><ul><li>增量渲染</li><li>暂停，终止，复用渲染任务</li><li>不同更新的优先级</li><li>并发方面新的基础能力</li></ul></li></ol></li><li><p>实现：Fiber把渲染更新过程拆分成多个子任务，每次只做一个执行单元，做完看是否还有剩余时间，如果有继续下一个任务；如果没有，挂起当前任务，将时间控制权交给主线程，等主线程不忙的时候在继续执行，即可以中断与恢复，恢复后也可以复用之前的中间状态，并给不同的任务赋予不同的优先级，其中每个任务更新单元为 React Element 对应的 Fiber节点。</p></li><li><p><strong>Fiber执行阶段：</strong></p><ol><li>协调阶段：可以认为是diff阶段，这个阶段可以被终止，这个阶段会找出所有节点的变更，例如节点的新增，删除，更新等等，这些变更React称为副作用</li><li>提交阶段：将上一阶段计算出来需要处理的副作用一次性执行了，这个阶段必须同步执行，不能被打断</li></ol></li></ul><h4 id="redux流程"><a href="#redux流程" class="headerlink" title="redux流程"></a>redux流程</h4><ol><li>用户发出Action，通过dispatch方法</li><li>Store自动调用Reducer，并传递两个参数：当前state和action,Reducer会返回新的state</li><li>state一旦有变化，store就会调用监听函数，更新view</li></ol><h4 id="render-的目的"><a href="#render-的目的" class="headerlink" title="render()的目的"></a>render()的目的</h4><ul><li>render返回react元素，是原生DOM组件的表示方式</li></ul><h4 id="redux三个原则"><a href="#redux三个原则" class="headerlink" title="redux三个原则"></a>redux三个原则</h4><p>1.数据来源的唯一性</p><ul><li>在redux中所有的数据都是存放在你的store中，这样做的目的就是保证数据来源的唯一性。那么为什么要这样做呢？使得创建通用应用程序变得很容易，因为服务器的状态可以序列化并水合到客户机中，而不需要额外的编码工作。单个状态树也使调试或检查应用程序变得更容易;它还使您能够在开发中持久保存应用程序的状态，以获得更快的开发周期。</li></ul><p>2.state只能是只读的状态</p><ul><li>state只能是只读的，在你的action中你可以去取它的值，但是不能够去改变它，这个时候采取的方式通常是深度拷贝state，并且将其返回给一个变量，然后改变这个变量，最后将值返回出去。而且要去改变数据你只能够在的reducer中，reducer是一个描述了对象发生了一个什么样过程的函数过程。  只读状态的好处，确保视图和网络回调都不会直接写入状态。</li></ul><p>3.使用纯函数进行改变：reducer是个纯函数</p><h4 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h4><ol><li>受控组件：在HTML的表单元素中，它们通常自己维护一套state，并随着用户的输入自己进行UI上的更新，这种行为是<strong>不被我们程序所管控</strong>的，而如果将React里的state属性和表单元素的值建立依赖关系，再通过onChange事件与setState()结合更新state属性，就能达到控制用户输入过程中表单发生的操作，React以这种方式控制取值的表单输入元素就叫做受控组件</li><li>非受控组件：如果表单元素并不经过<code>state</code>，而是通过<code>ref</code>修改或者直接操作<code>DOM</code>，那么它的数据无法通过<code>state</code>控制，这就是非受控组件。</li></ol><h4 id="高阶组件-HOC"><a href="#高阶组件-HOC" class="headerlink" title="高阶组件(HOC)"></a>高阶组件(HOC)</h4><ol><li>高阶组件就是一个函数，接收一个组件作为参数，并返回一个新的组件</li><li>可以用来实现权限控制</li></ol><h4 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h4><ol><li><a href="https://blog.csdn.net/snsHL9db69ccu1aIKl9r/article/details/109684911">通信方式</a></li></ol><h4 id="权限管理-1"><a href="#权限管理-1" class="headerlink" title="权限管理"></a>权限管理</h4><ol><li>页面权限：<ul><li>通过后端返回用户的权限列表</li><li>判断权限列表中是否包含该页面需要的权限</li><li>如果有，就渲染，如果没有就返回403</li></ul></li><li>按钮权限<ul><li>通过高阶组件方便统一管理</li><li>接收一个组件作为参数，然后根据权限返回不同的组件</li></ul></li></ol><h4 id="React和Vue区别和相同点"><a href="#React和Vue区别和相同点" class="headerlink" title="React和Vue区别和相同点"></a>React和Vue区别和相同点</h4><ul><li><p>相同点：</p><ol><li><p>都采用虚拟DOM，避免大量操作DOM</p></li><li><p>都支持服务器端渲染Vue是Nuxt,React是Next</p></li><li><p>组件化开发，一些传参方式相同</p></li><li><p>路由，状态管理等都是和框架分离的</p></li><li><p>都是JS的UI框架，数据驱动视图</p></li><li><p>都支持native，react是reactNative，vue是weex</p></li></ol></li><li><p>不同点：</p><ol><li>响应式原理不同：<ul><li>vue为Object.definedProperty,为每个属性添加getter和setter，当获取数据时，触发getter将数据添加到依赖中，修改数据时，通过setter通知依赖</li><li>React主要通过setState()来更新状态</li></ul></li><li>组件写法不同<ul><li>vue：template+script+style</li><li>react：jsx+inlineStyle</li></ul></li><li>组合不同功能的方式不同<ul><li>vue：mixin</li><li>react：通过HOC</li></ul></li><li>渲染过程不同：<ul><li>vue可以很快计算虚拟DOM之间的差异，跟踪每一个组件的依赖关系，不需要重新渲染组件树</li><li>react：全部子组件都会重新渲染，通过shouldComponentUpdate可以进行控制</li></ul></li><li>diff算法<ul><li>vue中的diff算法：当节点类型相同，类名不同时认为是不同的元素，会删除重建。列表对比时，vue采用两端到中间</li><li>react中的diff算法：ret会认为是同种节点，进行修改操作。列表对比时，react从左往右</li></ul></li></ol><p>使用场景</p><ul><li>Vue更快，更灵活，易于开发</li><li>react提倡更低粒度的封装，带来的组件复用性更高，并且react基本使用原生js，所以可定制性，复杂度更高。社区活跃（facebook），适合大型项目</li></ul></li></ul><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="npx-webpack打包流程"><a href="#npx-webpack打包流程" class="headerlink" title="npx webpack打包流程"></a>npx webpack打包流程</h4><ol><li>初始化参数阶段<br> 这一步会从我们配置的webpack.config.js中读取到对应的配置参数和shell命令中传入的参数进行合并得到最终打包配置参数。</li><li>开始编译准备阶段<br> 这一步我们会通过调用webpack()方法返回一个compiler方法，创建我们的compiler对象，并且注册各个Webpack Plugin。找到配置入口中的entry代码，调用compiler.run()方法进行编译。</li><li>模块编译阶段<br> 从入口模块进行分析，调用匹配文件的loaders对文件进行处理。同时分析模块依赖的模块，递归进行模块编译工作。</li><li>完成编译阶段<br> 在递归完成后，每个引用模块通过loaders处理完成同时得到模块之间的相互依赖关系。</li><li>输出文件阶段<br> 整理模块依赖关系，同时将处理后的文件输出到ouput的磁盘目录中。</li></ol><h4 id="loader作用"><a href="#loader作用" class="headerlink" title="loader作用"></a>loader作用</h4><ul><li>由于webpack只认识js和json文件，所以需要loader进行翻译，对其他资源进行预处理</li></ul><h4 id="常见的loader"><a href="#常见的loader" class="headerlink" title="常见的loader"></a>常见的loader</h4><ul><li>less-loader：less编译成css</li><li>css-loader：将css变成commonjs加载到js中</li><li>style-loader：创建style标签，将js中的样式资源插入标签内，并将标签加入head中</li></ul><h4 id="plugin作用"><a href="#plugin作用" class="headerlink" title="plugin作用"></a>plugin作用</h4><ul><li>解决loader无法解决的事，比如打包优化和代码压缩</li></ul><h4 id="常见的plugin"><a href="#常见的plugin" class="headerlink" title="常见的plugin"></a>常见的plugin</h4><ul><li>html-webpack-plugin:处理html资源</li><li>clean-webpack-plugin 每次打包时候，CleanWebpackPlugin 插件就会自动把上一次打的包删除</li></ul><h4 id="plugin和loader的区别"><a href="#plugin和loader的区别" class="headerlink" title="plugin和loader的区别"></a>plugin和loader的区别</h4><ol><li>loader：webpack本身只能打包js文件，针对css，图片等文件格式没法打包，就需要引入第三方的模块进行打包，loader虽然扩展了webpack，但是他只专注于转化文件，完成压缩，打包，语言翻译，仅仅是为了打包！！！！！！</li><li>plugin也是为了扩展webpack的功能，但是 plugin 是作用于webpack本身上的。而且plugin不仅只局限在打包，资源的加载上，它的功能要更加丰富。从打包优化和压缩，到重新定义环境变量，功能强大到可以用来处理各种各样的任务。webpack提供了很多开箱即用的插件：CommonChunkPlugin主要用于提取第三方库和公共模块，避免首屏加载的bundle文件，或者按需加载的bundle文件体积过大，导致加载时间过长，是一把优化的利器。而在多页面应用中，更是能够为每个页面间的应用程序共享代码创建bundle。<br>插件可以携带参数，所以在plugins属性传入new实例。</li></ol><h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><h4 id="何为nodejs"><a href="#何为nodejs" class="headerlink" title="何为nodejs"></a>何为nodejs</h4><ul><li>nodejs为基于javascript的 一种服务器端语言,nodejs的包管理器npm是一个非常不错的开源库生态系统</li></ul><h4 id="为什么使用nodejs"><a href="#为什么使用nodejs" class="headerlink" title="为什么使用nodejs"></a>为什么使用nodejs</h4><ol><li><p>优点</p><ol><li>轻量级， Node. js本身既是代码又是服务器，前后端使用同一语言</li><li>功能强大，非阻塞式I/O，在较慢的网络环境中，可以分块传输数据，事件驱动，擅长高并发访问</li></ol></li><li><p>缺点: 不适合CPU密集型应用，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。</p></li></ol><h4 id="nodejs全局对象"><a href="#nodejs全局对象" class="headerlink" title="nodejs全局对象"></a>nodejs全局对象</h4><ul><li>global、 process, console、 module和 exports</li></ul><h4 id="nodejs事件循环"><a href="#nodejs事件循环" class="headerlink" title="nodejs事件循环"></a>nodejs事件循环</h4><ul><li>事件循环其实就是一个事件队列，先加入先执行，执行完一次队列，再次循环遍历看有没有新事件加入队列。执行中的事件叫IO事件， setlmmediate在当前队列中立即执行，setTimout/setInterval把执行定时到下一个队列， process. nextTick在当前队列执行完，下次遍历前执行。所以总体顺序是：IO事件→ setImmediate→ setTimeout/setInterval→ process. nextTick。</li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h4 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h4><ol><li>图片懒加载</li><li>图片压缩(png-pngcrush ， gif-gifsicle ， jpeg-jpegtran)</li><li>CSS sprite<ul><li>使用方式：将背景图放入一张图中，通过bakcground-image，background-repeat，background-position，对所需要的图片进行定位。</li></ul></li><li>静态文件部署到CDN上</li><li>html，js，css压缩</li><li>首屏CSS检测，不是首屏的CSS单独打包并移动到首屏之外延迟加载</li><li>js按需加载</li><li>合理利用缓存<ul><li>keep-alive<ul><li>在组件切换过程中，将状态保存在内存中，防止重复渲染DOM，减少加载时间及性能消耗，提高用户体验性</li></ul></li><li>控制服务器的响应头cache-control</li></ul></li><li>Tree Shaking技术<ul><li>借助webpack的Tree Shaking技术，当我们引入一个模块时，不用引入这个模块的所有代码，只引入需要的代码</li></ul></li><li>路由懒加载</li></ol><h3 id="浏览器兼容"><a href="#浏览器兼容" class="headerlink" title="浏览器兼容"></a>浏览器兼容</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><ul><li>由于不同浏览器内核不同，所以每个浏览器采用的渲染引擎不同，导致相同的代码呈现在页面的样式不同，所以需要浏览器兼容</li><li>常见的浏览器内核：<ol><li>Webkit：旧版谷歌浏览器，Safari浏览器</li><li>Trident：IE浏览器，百度浏览器</li><li>Gecko: FireFox</li><li>Blink：谷歌</li></ol></li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="http与https区别"><a href="#http与https区别" class="headerlink" title="http与https区别"></a>http与https区别</h4><ol><li>http<ul><li>端口：80</li><li>无状态连接，明文传输，不安全</li></ul></li><li>https<ul><li>端口：443</li><li>增加了SSL安全层，加密传输更安全</li><li>CA证书，功能越强大，费用越高</li><li>握手较为费时，缓存不如http高效</li></ul></li></ol><h4 id="UDP与TCP"><a href="#UDP与TCP" class="headerlink" title="UDP与TCP"></a>UDP与TCP</h4><ol><li>UDP<ul><li>无连接的传输层协议，效率高，适用于实时应用，IP电话，视频会议，直播，以报文方式传输</li></ul></li><li>TCP<ul><li>面向连接的传输层协议，传输慢，适用于要求可靠传输的应用：文件传输，面向字节流</li></ul></li></ol><h4 id="五层模型，7层模型"><a href="#五层模型，7层模型" class="headerlink" title="五层模型，7层模型"></a>五层模型，7层模型</h4><ol><li>五层：<ul><li>应用层HTTP FTP telnet DNS SMTP()</li><li>传输层 TCP UDP(报文段)</li><li>网络层IP ICMP RIP(数据报)</li><li>数据链路层(帧)</li><li>物理层(比特)</li></ul></li><li>七层<ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul></li></ol><h4 id="响应码"><a href="#响应码" class="headerlink" title="响应码"></a>响应码</h4><ol><li><p>成功</p><p> 200——服务器成功返回网页<br> 201——提示知道新文件的URL<br> 202——接受和处理、但处理未完成<br> 203——返回信息不确定或不完整<br> 204——请求收到，但返回信息为空<br> 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件<br> 206——服务器已经完成了部分用户的GET请求</p></li><li><p>重定向</p><p> 300——请求的资源可在多处得到<br> 301——删除请求数据<br> 302——在其他地址发现了请求数据<br> 303——建议客户访问其他URL或访问方式<br> 304——客户端已经执行了GET，但文件未变化<br> 305——请求的资源必须从服务器指定的地址得到<br> 306——前一版本HTTP中使用的代码，现行版本中不再使用<br> 307——申明请求的资源临时性删除</p></li><li><p>请求错误</p><p> 400——错误请求，如语法错误<br> 401——请求授权失败<br> 402——保留有效ChargeTo头响应<br> 403——请求不允许<br> 404——请求的网页不存在<br> 405——用户在Request-Line字段定义的方法不允许</p></li><li><p>服务器错误</p><p> 500——服务器产生内部错误<br> 501——服务器不支持请求的函数<br> 502——服务器暂时不可用，有时是为了防止发生系统过载<br> 503——服务器超时过载或暂停维修<br> 504——关口过载，服务器使用另一个关口或服务来响应用户，等待时间设定值较长<br> 505——服务器不支持或拒绝支请求头中指定的HTTP版本</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;html&quot;&gt;&lt;a href=&quot;#html&quot; class=&quot;headerlink&quot; title=&quot;html&quot;&gt;&lt;/a&gt;html&lt;/h3&gt;&lt;h4 id=&quot;DOCTYPE作用&quot;&gt;&lt;a href=&quot;#DOCTYPE作用&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="知识点" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="react" scheme="https://blog.wxywxy.cn/tags/react/"/>
    
    <category term="vue" scheme="https://blog.wxywxy.cn/tags/vue/"/>
    
    <category term="html" scheme="https://blog.wxywxy.cn/tags/html/"/>
    
    <category term="css" scheme="https://blog.wxywxy.cn/tags/css/"/>
    
    <category term="js" scheme="https://blog.wxywxy.cn/tags/js/"/>
    
    <category term="框架" scheme="https://blog.wxywxy.cn/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>useState与useRef</title>
    <link href="https://blog.wxywxy.cn/2022/09/20/useState%E4%B8%8EuseRef/"/>
    <id>https://blog.wxywxy.cn/2022/09/20/useState%E4%B8%8EuseRef/</id>
    <published>2022-09-20T08:46:23.000Z</published>
    <updated>2022-10-17T03:41:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="useState"><a href="#useState" class="headerlink" title="useState"></a>useState</h3><ul><li><p>react中一般使用useState方法为，初始化值为second，设置first的方法为setfirst。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, setfirst] = <span class="title function_">useState</span>(second)</span><br></pre></td></tr></table></figure></li><li><p>一般情况下使用不会有什么问题，但是在你刚设置完状态后不能立刻使用该状态，原因是setState是异步执行的，何为异步执行？javascript为单线程，意思是只能自上而下顺序执行，如果某一环节出现问题，之后的也不会执行，所以javascript引入了异步执行操作。</p><ul><li><p>js异步执行机制：</p><ul><li><p>首先判断该任务是同步还是异步，同步进入主线程顺序执行，异步的进入Event table</p></li><li><p>异步任务在Event table中注册函数，然后被推入Event queue</p></li><li><p>当主线程执行完所有的同步任务空闲之后，才去Event queue中查看是否有可执行的异步任务，如果有，就推入到主线程中执行</p></li></ul></li></ul></li><li><p>由于setState是异步的，所以下面这段代码点击重置后不会立刻获得默认列表，但是第二次点击会获得默认列表，显然这是不符合预期的，所以应该怎么解决呢？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const fun = () =&gt; &#123;</span><br><span class="line">const [first, setfirst] = useState(second)</span><br><span class="line">  //页面加载时，获取列表并展示</span><br><span class="line">  useEffect(() =&gt; &#123;</span><br><span class="line">    getList()</span><br><span class="line">  &#125; , [])</span><br><span class="line">    //搜索就是通过传入不同参数获得不同的结果列表</span><br><span class="line">  const getList = () =&gt; &#123;</span><br><span class="line">    //发送请求，获取数据展现到页面上</span><br><span class="line">    .......</span><br><span class="line">  &#125;</span><br><span class="line">  //重置按钮就是将输入框置为空，然后获取默认列表</span><br><span class="line">  const reset = () =&gt; &#123;</span><br><span class="line">    setfirst(&#x27;&#x27;)</span><br><span class="line">    getList()</span><br><span class="line">  &#125;</span><br><span class="line">  return (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type = &quot;text&quot; value = &quot;&#123;first&#125;&quot;/&gt;</span><br><span class="line">    &lt;button onclick = &#123;getList&#125;&gt;搜索&lt;/button&gt;</span><br><span class="line">            &lt;button onclick = &#123;reset&#125;&gt;重置&lt;/button&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><ul><li>上述的问题可以通过useRef来解决，使用方式如下，这种方式就可以实现点击reset后，清空输入框的值，并获取默认列表展示。</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fun</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">//使用useref定义状态</span></span><br><span class="line">  <span class="keyword">const</span> first = <span class="title function_">useRef</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">//页面加载时，获取列表并展示</span></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">getList</span>()</span><br><span class="line">  &#125; , [])</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getList</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    .......</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">reset</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">//通过current.value来改变值</span></span><br><span class="line">    first.<span class="property">current</span>.<span class="property">value</span> = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="title function_">getList</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    //input通过ref绑定</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span> = <span class="string">&quot;text&quot;</span> <span class="attr">ref</span> = <span class="string">&#123;first&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span> = <span class="string">&#123;getList&#125;</span>&gt;</span>搜索<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span> = <span class="string">&#123;reset&#125;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><ul><li>受控组件与非受控组件<ul><li>受控组件：类似于useState这种，将组件的值放入state中进行维护，所以要访问组件的值，直接在state中进行读取，不必获取对应组件了，设置组件的值也要通过setState进行设置，整个过程就是组件的状态与维护。</li><li>非受控组件：react本身并没有维护组件的值，想要获取组件的值，通过ref获取组件，然后通过ref获取或者设置组件的值，随取随用，且设置值后立即生效。</li></ul></li><li>由于useRef设置值是同步的，所以会立即生效。</li></ul><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3><ul><li>在使用antd的Input输入框组件，通过useRef获取和设置组件的值，获取值的方式：first.current.input.value,设置值的方式：first.current.input.value = ‘’,类似于上面的例子，使用antd的input框点击重置后，有一瞬间清空了input，但是马上又恢复了之前input框输入的值，检查之后，感觉代码没什么问题，可能是antd的BUG吧。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>遇到问题：就是想点击reset后，清空输入框，并发送请求，展示默认的列表，<ol><li>刚开始使用受控组件useState，但是由于是异步更改状态的，所以不行</li><li>后来使用非受控组件useRef，但是由于使用的antd，会有bug，也不行，如果使用html原生的，就没有问题</li><li>最后先使用受控组件：useState，input绑定的是useState的值，定义一个非受控组件useRef，使用useEffect，监测useState的值，当他的值改变，就将他的值赋给useRef所定义的那个变量。在发送请求的getList函数中读取useRef所定义的值即可。</li></ol></li></ol><p>​    </p><p>​    </p><p>​    </p><p>​    </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;useState&quot;&gt;&lt;a href=&quot;#useState&quot; class=&quot;headerlink&quot; title=&quot;useState&quot;&gt;&lt;/a&gt;useState&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;react中一般使用useState方法为，初始化值为second，设置f</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="react" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/react/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="react" scheme="https://blog.wxywxy.cn/tags/react/"/>
    
    <category term="Hook" scheme="https://blog.wxywxy.cn/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>回溯法</title>
    <link href="https://blog.wxywxy.cn/2022/09/19/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    <id>https://blog.wxywxy.cn/2022/09/19/%E5%9B%9E%E6%BA%AF%E6%B3%95/</id>
    <published>2022-09-19T08:44:02.000Z</published>
    <updated>2022-10-13T01:11:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回溯法三部曲"><a href="#回溯法三部曲" class="headerlink" title="回溯法三部曲"></a>回溯法三部曲</h3><ul><li>回溯法中，<strong>for循环就是在本层遍历（广度遍历），递归就是向深层次遍历（深度遍历）</strong></li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">backTracking</span>(<span class="params">参数</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(终止条件) &#123;</span><br><span class="line">      存放结果</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(选择本层集合中元素（树结构中的同层元素）) &#123;</span><br><span class="line">   处理节点</span><br><span class="line">      <span class="title function_">backTracking</span>(树结构中下一层)</span><br><span class="line">    回溯，撤销结果</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="N皇后"><a href="#N皇后" class="headerlink" title="N皇后"></a>N皇后</h3><ol><li>问题描述：N皇后问题，在n*n的棋盘上放置n个皇后，每个皇后的同行，同列，同对角线不能有其他皇后</li><li><a href="https://leetcode.cn/problems/n-queens/">leetcode链接</a></li><li>树形结构思路：</li></ol><p><img src="https://qianrui-xiaoyang.oss-cn-hangzhou.aliyuncs.com/img/blog/N%E7%9A%87%E5%90%8E.png" alt="image"></p><ol start="4"><li>通过上图，根据模板，可以大致写出回溯的代码</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//startRow代表当前是第几行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">backTracking</span>(<span class="params">startRow , path</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(startRow === n) result.<span class="title function_">push</span>(path)</span><br><span class="line">  <span class="comment">//向深层次进发</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">    <span class="comment">//如果path[startRow , col]不会被攻击</span></span><br><span class="line">    <span class="keyword">if</span>(isvaild) &#123;</span><br><span class="line">      path[startRow][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">      <span class="title function_">backtracking</span>(startRow + <span class="number">1</span> , path)</span><br><span class="line">      path[startRow][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="5"><li>其余代码包括判断是否在同一行，同一列，同一对角线</li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string[][]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> solveNQueens = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="comment">//初始定义chessBoard为二维数组，fill&#x27;.&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> chessBoard = <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>([]).<span class="title function_">map</span>(<span class="function">() =&gt;</span> <span class="keyword">new</span> <span class="title class_">Array</span>(n).<span class="title function_">fill</span>(<span class="string">&#x27;.&#x27;</span>))</span><br><span class="line">    <span class="comment">//存储结果的数组</span></span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="comment">//回溯函数</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracking</span> = (<span class="params">startRow , chessBoard</span>) =&gt; &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(startRow === n) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(<span class="title function_">transformChessBoard</span>(chessBoard))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环本层</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> col = <span class="number">0</span>; col &lt; n; col++) &#123;</span><br><span class="line">            <span class="comment">//判断是否会被攻击</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="title function_">isvaild</span>(startRow , col , chessBoard)) &#123;</span><br><span class="line">                <span class="comment">//如果不会，就放Q</span></span><br><span class="line">                chessBoard[startRow][col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">                <span class="comment">//向深层遍历</span></span><br><span class="line">                <span class="title function_">backTracking</span>(startRow+<span class="number">1</span> , chessBoard)</span><br><span class="line">               <span class="comment">//回溯</span></span><br><span class="line">                chessBoard[startRow][col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracking</span>(<span class="number">0</span> , chessBoard)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"><span class="comment">//判断上方的列，45度方向，135度方向是否有Q，不用判断行因为每次for循环，只会选一行的一个元素，不用判断</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isvaild</span>(<span class="params">row , col , chessBoard</span>) &#123;</span><br><span class="line">    <span class="comment">//判断一列中是否有其他Q</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(chessBoard[i][col] === <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断45度方向是否有Q</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span> , j = col - <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i-- , j--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(chessBoard[i][j] === <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断135度方向是否有Q</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = row - <span class="number">1</span> , j = col + <span class="number">1</span>; i &gt;=<span class="number">0</span> &amp;&amp; j &lt; n; i-- , j++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(chessBoard[i][j] === <span class="string">&#x27;Q&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将[&#x27;Q&#x27;,&#x27;.&#x27;,&#x27;.&#x27;,&#x27;.&#x27;]转换成&quot;Q...&quot;题目要求的形式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">transformChessBoard</span>(<span class="params">chessBoard</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> chessBoardBack = []</span><br><span class="line">        chessBoard.<span class="title function_">forEach</span>(<span class="function"><span class="params">row</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> rowStr = <span class="string">&#x27;&#x27;</span></span><br><span class="line">            row.<span class="title function_">forEach</span>(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">                rowStr += value</span><br><span class="line">            &#125;)</span><br><span class="line">            chessBoardBack.<span class="title function_">push</span>(rowStr)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chessBoardBack</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">括号生成</a></h3><ol><li>该问题的终止条件：<ul><li>左括号的数量或者右括号的数量小于零</li><li>左括号的数量大于右括号，说明该字符串不符合语法，出现了类似’)()’的情况</li><li>左括号和右括号的数量为0，说明正常配对完毕，可以放入结果中</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> generateParenthesis = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> result = []</span><br><span class="line">    <span class="keyword">let</span> path = []</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">backTracking</span> = (<span class="params">right , left , path</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &lt; <span class="number">0</span> || right &lt; <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span>(left === <span class="number">0</span> &amp;&amp; right === <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="title function_">push</span>(path.<span class="title function_">join</span>(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="title function_">push</span>(<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        <span class="title function_">backTracking</span>(right , left - <span class="number">1</span> , [...path])</span><br><span class="line">        path.<span class="title function_">pop</span>()</span><br><span class="line"></span><br><span class="line">        path.<span class="title function_">push</span>(<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">        <span class="title function_">backTracking</span>(right - <span class="number">1</span> , left , [...path])</span><br><span class="line">        path.<span class="title function_">pop</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">backTracking</span>(n,n,path)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="组合和排列问题"><a href="#组合和排列问题" class="headerlink" title="组合和排列问题"></a>组合和排列问题</h3><ol><li>组合问题和排列问题的区别：[1,2,3]和[1,3,2]算两种排列，但是只算一种组合</li><li>在回溯法中，</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;回溯法三部曲&quot;&gt;&lt;a href=&quot;#回溯法三部曲&quot; class=&quot;headerlink&quot; title=&quot;回溯法三部曲&quot;&gt;&lt;/a&gt;回溯法三部曲&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;回溯法中，&lt;strong&gt;for循环就是在本层遍历（广度遍历），递归就是向深层次遍历（深度遍历）</summary>
      
    
    
    
    <category term="算法" scheme="https://blog.wxywxy.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯法" scheme="https://blog.wxywxy.cn/categories/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
    
    <category term="算法" scheme="https://blog.wxywxy.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="回溯法" scheme="https://blog.wxywxy.cn/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>uni-app开发中的问题</title>
    <link href="https://blog.wxywxy.cn/2022/07/31/uni/"/>
    <id>https://blog.wxywxy.cn/2022/07/31/uni/</id>
    <published>2022-07-31T02:18:26.000Z</published>
    <updated>2023-07-31T10:03:46.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络请求问题"><a href="#网络请求问题" class="headerlink" title="网络请求问题"></a>网络请求问题</h3><ul><li>uni-app中发送网络请求，由于原生API request不支持配置拦截器，并且也不支持使用axios，所以需要使用<code>@escook/request-miniprogram</code>插件来封装请求拦截器<h3 id="分包问题"><a href="#分包问题" class="headerlink" title="分包问题"></a>分包问题</h3></li><li> 在项目根目录下创建分包的根目录<code>subpkg</code></li><li> 在<code>pages.json</code>中和<code>pages</code>节点平级的位置声明<code>subPackages</code>节点，用来定义分包相关结构</li><li> 之后在subpkg中新建需要分包的页面，创建时选择分包为<code>subpkg</code>，创建完成后，页面信息就会自动添加到<code>subPackages</code>下的<code>pages</code>目录下</li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;subPackages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">//代表分包根目录</span></span><br><span class="line"><span class="attr">&quot;root&quot;</span><span class="punctuation">:</span> <span class="string">&quot;subpkg&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;pages&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;path&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;goods_detail/goods_detail&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;style&quot;</span> <span class="punctuation">:</span>                                                                                    </span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;navigationBarTitleText&quot;</span><span class="punctuation">:</span> <span class="string">&quot;商品详情&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;enablePullDownRefresh&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">                </span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="uni-switchTab和uni-navigateTo"><a href="#uni-switchTab和uni-navigateTo" class="headerlink" title="uni.switchTab和uni.navigateTo"></a>uni.switchTab和uni.navigateTo</h3><ul><li>跳转到 <code>tabBar</code> 页面必须使用<code>uni-switchBar</code>，并关闭其他所有非 <code>tabBar</code> 页面。</li><li><code>uni.navigateTo</code>跳转到应用内的某个页面，但是不能跳转到<code>tabBar</code>页面</li></ul><h3 id="切换一级菜单，滚动条的位置还在上个一级菜单滑动的位置"><a href="#切换一级菜单，滚动条的位置还在上个一级菜单滑动的位置" class="headerlink" title="切换一级菜单，滚动条的位置还在上个一级菜单滑动的位置"></a>切换一级菜单，滚动条的位置还在上个一级菜单滑动的位置</h3><ul><li>解决方法：<code>scroll-view</code>标签有个属性<code>scroll-top</code>，可以设置滚动条的位置，所以我们可以设置一个属性，当切换一级菜单时，将该属性置为0，但是有个问题：<code>scroll-top</code>如果没有变化，一直是0，那这样不会起效果，所以我们可以让该值在0和1之间切换，如果是0，就把它置为1，如果是1就置为0，虽然会有一像素的偏差，但是肉眼看不到<h3 id="页面跳转时携带的参数"><a href="#页面跳转时携带的参数" class="headerlink" title="页面跳转时携带的参数"></a>页面跳转时携带的参数</h3></li><li>页面跳转时携带的参数可以在跳转的页面的<code>onLoad</code>的生命周期中取到<h3 id="关于上拉触底刷新数据和下拉刷新"><a href="#关于上拉触底刷新数据和下拉刷新" class="headerlink" title="关于上拉触底刷新数据和下拉刷新"></a>关于上拉触底刷新数据和下拉刷新</h3></li></ul><ol><li><p>在<code>pages.json</code>中对想要设置的页面的style中添加<code>onReachBottomDistance</code>属性，进行上拉触底的距离设置,添加<code>enablePullDownRefresh</code>属性，进行下拉刷新设置</p></li><li><p>在页面中上拉触底函数<code>onReachBottom</code>中进行操作</p></li><li><p>在页面下拉刷新函数<code>onPullDownRefresh</code>中进行清除原有数据，并再次请求数据.注意：<strong>需要手动关闭下拉刷新，调用请求数据的函数时，传递一个函数作为参数，该函数为关闭下拉刷新的函数</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重新发送请求</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">getGoodsList</span>(<span class="function">() =&gt;</span> uni.<span class="title function_">stopPullDownRefresh</span>())</span><br><span class="line"><span class="comment">//在getGoodsList中判断，如果有这个参数，就执行该函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="title function_">getGoodsList</span>(<span class="params">callback</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    callback &amp;&amp; <span class="title function_">callback</span>()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h3></li><li><p>关于uni-num-box输入非法数字,就会显示NAN，所以在源码中将数字先转为number，如果是NAN，默认置为1</p></li><li><p>问题：使用滑动删除组件uin-swiper-action，会报错<code>TypeError: this.swipeaction.closeOther is not a function</code><br>解决方法：在<code>uni-modules/uni-swipe-action/uni-swipe-action-item/mpwxs.js</code>的methods的<code>closeSwipe</code>方法，修改为如下所示，添加了条件编译</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">closeSwipe</span>(<span class="params">e</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">autoClose</span>) <span class="keyword">return</span></span><br><span class="line"><span class="comment">// #ifdef H5</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">swipeaction</span>.<span class="title function_">closeOther</span>(<span class="variable language_">this</span>)</span><br><span class="line"><span class="comment">// #endif</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>问题：使用官方接口<code>uni.chooseAddress</code>报错，报错信息：<code>chooseAddress:fail the api need to be declared in the requiredPrivateInfos field in app.json/ext.json</code><br>解决方法：manifest.json 文件”mp-weixin” 节点 加一行配置<code>&quot;requiredPrivateInfos&quot;:[&quot;chooseAddress&quot;]</code>。原因为使用地理位置相关的接口需要提前进行配置</p></li></ol><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ol><li>首先点击登录按钮，open-type属性选择getUserInfo，然后通过@getuserinfo中定义的回调获取用户信息.</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn-login&quot;</span> <span class="attr">open-type</span>=<span class="string">&quot;getUserInfo&quot;</span> @<span class="attr">getuserinfo</span>=<span class="string">&quot;getUserInfo&quot;</span>&gt;</span>一键登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>通过uni.login,获取code</li><li>通过第一步获取的信息和第二步获取的code封装参数，发送登录请求</li><li>登录成功后得到token，通过uni.setStoragesync存储在本地</li><li>在之后的支付请求时，需要在请求头中携带token</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;网络请求问题&quot;&gt;&lt;a href=&quot;#网络请求问题&quot; class=&quot;headerlink&quot; title=&quot;网络请求问题&quot;&gt;&lt;/a&gt;网络请求问题&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;uni-app中发送网络请求，由于原生API request不支持配置拦截器，并且也不支持使用a</summary>
      
    
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="uni-app" scheme="https://blog.wxywxy.cn/categories/%E5%89%8D%E7%AB%AF/uni-app/"/>
    
    
    <category term="前端" scheme="https://blog.wxywxy.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="uni-app" scheme="https://blog.wxywxy.cn/tags/uni-app/"/>
    
  </entry>
  
</feed>
